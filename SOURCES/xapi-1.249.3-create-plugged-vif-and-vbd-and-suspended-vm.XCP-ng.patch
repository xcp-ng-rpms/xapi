Enable to create a VM in `Suspended` state with a `suspend_VDI` set:
* add to the `vm.create` method:
   * `power_state` with default value: `Halted`
   * `suspend_VDI` with default value: `Ref.null`
   * `last_booted_record` with default value: `""`
   * `last_boot_CPU_flags` with default value: `[]`
   The default behavior is not changed
* add `device` (default: '') and `currently_attached` (default: false) to the `VBD.create` method to allow the creation of an already plugged VBD. the new fields can only be used if the VM is suspended. Default behaviour is kept.
* add `currently_attached` (default: false) to the `VIF.create` method to allow the creation of an already plugged VIF. the new fields can only be used if the VM is suspended. Default behaviour is kept.

diff --git a/ocaml/idl/datamodel.ml b/ocaml/idl/datamodel.ml
index a8a1503ce..85eeab1fc 100644
--- a/ocaml/idl/datamodel.ml
+++ b/ocaml/idl/datamodel.ml
@@ -1486,7 +1486,7 @@ end
 (* These are included in vbds and vifs -- abstracted here to keep both these uses consistent *)
 let device_status_fields =
   [
-    field ~ty:Bool ~qualifier:DynamicRO "currently_attached" "is the device currently attached (erased on reboot)";
+    field ~ty:Bool ~qualifier:StaticRO ~default_value:(Some (VBool false)) ~lifecycle:[Changed, rel_stockholm, "Become static to allow plugged VIF and VBD creation for Suspended VM"] "currently_attached" "is the device currently attached (erased on reboot)";
     field ~ty:Int ~qualifier:DynamicRO "status_code" "error/success code associated with last attach-operation (erased on reboot)";
     field ~ty:String ~qualifier:DynamicRO "status_detail" "error/success information associated with last attach-operation status (erased on reboot)";
     field ~ty:(Map(String, String)) ~qualifier:DynamicRO "runtime_properties" "Device runtime properties"
@@ -3013,7 +3013,7 @@ module VBD = struct
            field ~qualifier:StaticRO ~ty:(Ref _vm) "VM" "the virtual machine";
            field ~qualifier:StaticRO ~ty:(Ref _vdi) "VDI" "the virtual disk";

-           field ~qualifier:DynamicRO "device" "device seen by the guest e.g. hda1";
+           field ~qualifier:StaticRO ~ty:String ~default_value:(Some (VString "")) ~lifecycle:[Changed, rel_stockholm, "Become static to allow plugged VBD creation for Suspended VM"] "device" "device seen by the guest e.g. hda1";
            field "userdevice" "user-friendly device name e.g. 0,1,2,etc.";
            field ~ty:Bool "bootable" "true if this VBD is bootable";
            field ~qualifier:StaticRO ~ty:mode "mode" "the mode the VBD should be mounted with";
diff --git a/ocaml/idl/datamodel_vm.ml b/ocaml/idl/datamodel_vm.ml
index 0b15b0c89..07bd95e75 100644
--- a/ocaml/idl/datamodel_vm.ml
+++ b/ocaml/idl/datamodel_vm.ml
@@ -1284,6 +1284,7 @@ let set_NVRAM_EFI_variables = call ~flags:[`Session]
                    ]
       ~lifecycle:[
         Published, rel_rio, "";
+        Changed, rel_stockholm, "possibility to create a VM in suspended mode with a suspend_VDI set";
       ]
       ~messages_default_allowed_roles:_R_VM_ADMIN
       ~messages:[ snapshot; snapshot_with_quiesce; clone; copy; revert; checkpoint;
@@ -1361,13 +1362,13 @@ let set_NVRAM_EFI_variables = call ~flags:[`Session]
       ~contents:
         ([ uid _vm;
          ] @ (allowed_and_current_operations operations) @ [
-           field ~writer_roles:_R_VM_OP ~qualifier:DynamicRO ~ty:power_state "power_state" "Current power state of the machine";
            namespace ~name:"name" ~contents:(names oss_since_303 RW) ();
+           field ~writer_roles:_R_VM_OP ~qualifier:StaticRO ~default_value:(Some (VEnum "Halted")) ~lifecycle:[Changed, rel_stockholm, "Become static to allow Suspended VM creation"] ~ty:power_state "power_state" "Current power state of the machine";

            field ~ty:Int "user_version" "Creators of VMs and templates may store version information here.";
            field ~effect:true ~ty:Bool "is_a_template" "true if this is a template. Template VMs can never be started, they are used only for cloning other VMs";
            field ~ty:Bool ~default_value:(Some (VBool false)) ~qualifier:DynamicRO ~writer_roles:_R_POOL_ADMIN ~lifecycle:[Published, rel_falcon, "Identifies default templates"] "is_default_template" "true if this is a default template. Default template VMs can never be started or migrated, they are used only for cloning other VMs";
-           field ~qualifier:DynamicRO ~ty:(Ref _vdi) "suspend_VDI" "The VDI that a suspend image is stored on. (Only has meaning if VM is currently suspended)";
+           field ~qualifier:StaticRO ~default_value:(Some (VRef null_ref)) ~lifecycle:[Changed, rel_stockholm, "Become static to allow Suspended VM creation"] ~ty:(Ref _vdi) "suspend_VDI" "The VDI that a suspend image is stored on. (Only has meaning if VM is currently suspended)";

            field ~writer_roles:_R_VM_POWER_ADMIN ~qualifier:DynamicRO ~ty:(Ref _host) "resident_on" "the host the VM is currently resident on";
            field ~writer_roles:_R_VM_POWER_ADMIN ~in_oss_since:None ~qualifier:DynamicRO ~default_value:(Some (VRef null_ref)) ~ty:(Ref _host) "scheduled_to_be_resident_on" "the host on which the VM is due to be started/resumed/migrated. This acts as a memory reservation indicator";
@@ -1395,14 +1396,14 @@ let set_NVRAM_EFI_variables = call ~flags:[`Session]
            field  ~ty:(Map(String, String)) "other_config" "additional configuration" ~map_keys_roles:["pci", _R_POOL_ADMIN; ("folder",(_R_VM_OP));("XenCenter.CustomFields.*",(_R_VM_OP))];
            field ~qualifier:DynamicRO ~ty:Int "domid" "domain ID (if available, -1 otherwise)";
            field ~qualifier:DynamicRO ~in_oss_since:None ~ty:String "domarch" "Domain architecture (if available, null string otherwise)";
-           field ~in_oss_since:None ~qualifier:DynamicRO ~ty:(Map(String, String)) "last_boot_CPU_flags" "describes the CPU flags on which the VM was last booted";
+           field ~in_oss_since:None ~qualifier:StaticRO ~ty:(Map(String, String)) ~default_value:(Some (VMap [])) "last_boot_CPU_flags" "describes the CPU flags on which the VM was last booted";
            field ~qualifier:DynamicRO ~ty:Bool "is_control_domain" "true if this is a control domain (domain 0 or a driver domain)";
            field ~qualifier:DynamicRO ~ty:(Ref _vm_metrics) "metrics" "metrics associated with this VM";
            field ~qualifier:DynamicRO ~ty:(Ref _vm_guest_metrics) "guest_metrics" "metrics associated with the running guest";
            (* This was an internal field in Rio, Miami beta1, Miami beta2 but is now exposed so that
               	   it will be included automatically in Miami GA exports and can be restored, important if
               	   the VM is in a suspended state *)
-           field ~in_oss_since:None ~internal_only:false ~in_product_since:rel_miami ~qualifier:DynamicRO ~ty:String "last_booted_record" "marshalled value containing VM record at time of last boot, updated dynamically to reflect the runtime state of the domain" ~default_value:(Some (VString ""));
+           field ~in_oss_since:None ~internal_only:false ~in_product_since:rel_miami ~qualifier:StaticRO ~ty:String "last_booted_record" "marshalled value containing VM record at time of last boot, updated dynamically to reflect the runtime state of the domain" ~default_value:(Some (VString ""));
            field ~in_oss_since:None ~ty:String "recommendations" "An XML specification of recommended values and ranges for properties of this VM";
            field ~effect:true ~in_oss_since:None ~ty:(Map(String, String)) ~in_product_since:rel_miami ~qualifier:RW "xenstore_data" "data to be inserted into the xenstore tree (/local/domain/<domid>/vm-data) after the VM is created." ~default_value:(Some (VMap []));
            field ~writer_roles:_R_POOL_OP ~in_oss_since:None ~ty:Bool ~in_product_since:rel_orlando ~internal_deprecated_since:rel_boston ~qualifier:StaticRO "ha_always_run" "if true then the system will attempt to keep the VM running as much as possible." ~default_value:(Some (VBool false));
diff --git a/ocaml/perftest/createVM.ml b/ocaml/perftest/createVM.ml
index 08c44dd5f..15cea18c8 100644
--- a/ocaml/perftest/createVM.ml
+++ b/ocaml/perftest/createVM.ml
@@ -50,8 +50,8 @@ let make_iscsi session_id pool network =
     let newvm = Client.VM.clone rpc session_id template "ISCSI target server" in
     Client.VM.provision rpc session_id newvm ;
     let _ (* isovbd *) =
-      Client.VBD.create rpc session_id newvm iscsi_iso "0" true `RO `CD false
-        false [] "" []
+      Client.VBD.create rpc session_id newvm iscsi_iso "" "0" true `RO `CD false
+        false [] false "" []
     in
     let realpool = List.hd (Client.Pool.get_all rpc session_id) in
     let defaultsr = Client.Pool.get_default_SR rpc session_id realpool in
@@ -63,8 +63,8 @@ let make_iscsi session_id pool network =
       in
       let userdevice = Printf.sprintf "%d" (i + 1) in
       ignore
-        (Client.VBD.create rpc session_id newvm storage_vdi userdevice false `RW
-           `Disk false false [] "" [])
+        (Client.VBD.create rpc session_id newvm storage_vdi "" userdevice false `RW
+           `Disk false false [] false "" [])
     done ;
     Client.VM.set_PV_bootloader rpc session_id newvm "pygrub" ;
     Client.VM.set_PV_args rpc session_id newvm
@@ -72,7 +72,7 @@ let make_iscsi session_id pool network =
     Client.VM.set_HVM_boot_policy rpc session_id newvm "" ;
     let (_ : API.ref_VIF) =
       Client.VIF.create rpc session_id "0" network newvm "" 1500L
-        [(oc_key, pool.key)] "" [] `network_default [] []
+        [(oc_key, pool.key)] false "" [] `network_default [] []
     in
     Client.VM.add_to_other_config rpc session_id newvm oc_key pool.key ;
     let localhost_uuid = Inventory.lookup "INSTALLATION_UUID" in
@@ -120,7 +120,7 @@ let make ~rpc ~session_id ~pool ~vm ~networks ~storages =
           (Client.VBD.create ~rpc ~session_id ~vM:clone ~vDI:newdisk
              ~userdevice:(string_of_int userdevice) ~bootable:false ~mode:`RW
              ~_type:`Disk ~unpluggable:true ~empty:false ~qos_algorithm_type:""
-             ~qos_algorithm_params:[] ~other_config:[])
+             ~qos_algorithm_params:[] ~other_config:[] ~device:"" ~currently_attached:false)
       done ;
       Client.VM.provision ~rpc ~session_id ~vm:clone ;
       for device = 0 to min vm.vifs (Array.length networks) - 1 do
@@ -128,7 +128,7 @@ let make ~rpc ~session_id ~pool ~vm ~networks ~storages =
           (Client.VIF.create ~rpc ~session_id ~device:(string_of_int device)
              ~network:networks.(device) ~vM:clone ~mAC:"" ~mTU:1500L
              ~other_config:[] ~qos_algorithm_type:"" ~qos_algorithm_params:[]
-             ~locking_mode:`network_default ~ipv4_allowed:[] ~ipv6_allowed:[])
+             ~locking_mode:`network_default ~ipv4_allowed:[] ~ipv6_allowed:[] ~currently_attached:false)
       done ;
       Client.VM.set_memory_static_min ~rpc ~session_id ~self:clone
         ~value:16777216L ;
diff --git a/ocaml/perftest/createpool.ml b/ocaml/perftest/createpool.ml
index 5a3a301f8..1be54e0c5 100644
--- a/ocaml/perftest/createpool.ml
+++ b/ocaml/perftest/createpool.ml
@@ -65,7 +65,7 @@ let initialise session_id template pool =
           ~network:net ~vM:template ~mAC:"" ~mTU:1500L
           ~other_config:[(oc_key, pool.key)] ~qos_algorithm_type:""
           ~qos_algorithm_params:[] ~locking_mode:`network_default
-          ~ipv4_allowed:[] ~ipv6_allowed:[])
+          ~ipv4_allowed:[] ~ipv6_allowed:[] ~currently_attached:false)
   in
   (* Create a disk for local storage *)
   debug "Creating a disk for local storage on the template" ;
@@ -82,7 +82,7 @@ let initialise session_id template pool =
     Client.VBD.create ~rpc ~session_id ~vM:template ~vDI:newdisk
       ~userdevice:sr_disk_device ~bootable:false ~mode:`RW ~_type:`Disk
       ~unpluggable:true ~empty:false ~qos_algorithm_type:""
-      ~qos_algorithm_params:[] ~other_config:[(oc_key, pool.key)]
+      ~qos_algorithm_params:[] ~other_config:[(oc_key, pool.key)] ~device:"" ~currently_attached:false
   in
   debug "Setting up xenstore keys" ;
   (* Set up the various xenstore keys *)
diff --git a/ocaml/quicktest/qt.ml b/ocaml/quicktest/qt.ml
index 40b4b96d6..b811b27de 100644
--- a/ocaml/quicktest/qt.ml
+++ b/ocaml/quicktest/qt.ml
@@ -199,6 +199,8 @@ module VDI = struct
         ~userdevice:"autodetect" ~bootable:false ~mode ~_type:`Disk
         ~unpluggable:true ~qos_algorithm_type:"" ~qos_algorithm_params:[]
         ~other_config:[]
+        ~device:""
+        ~currently_attached:false
     in
     Xapi_stdext_pervasives.Pervasiveext.finally
       (fun () ->
diff --git a/ocaml/quicktest/quicktest_vdi.ml b/ocaml/quicktest/quicktest_vdi.ml
index 01e340ee1..3e05f5306 100644
--- a/ocaml/quicktest/quicktest_vdi.ml
+++ b/ocaml/quicktest/quicktest_vdi.ml
@@ -209,6 +209,7 @@ let vbd_create_helper ~rpc ~session_id ~vM ~vDI ?(userdevice = "autodetect") ()
   Client.Client.VBD.create ~rpc ~session_id ~vM ~vDI ~userdevice ~bootable:false
     ~mode:`RW ~_type:`Disk ~unpluggable:true ~empty:false ~other_config:[]
     ~qos_algorithm_type:"" ~qos_algorithm_params:[]
+    ~device:"" ~currently_attached:false

 (** Check that snapshot works regardless which host has the VDI activated *)
 let vdi_snapshot_in_pool rpc session_id sr_info () =
@@ -320,7 +321,7 @@ let vdi_general_test rpc session_id sr_info () =
         Client.Client.VBD.create ~rpc ~session_id ~vM:dom0 ~vDI:newvdi
           ~userdevice:device ~bootable:false ~mode:`RW ~_type:`Disk
           ~unpluggable:true ~empty:false ~other_config:[] ~qos_algorithm_type:""
-          ~qos_algorithm_params:[]
+          ~qos_algorithm_params:[] ~device:"" ~currently_attached:false
       in
       Xapi_stdext_pervasives.Pervasiveext.finally
         (fun () ->
diff --git a/ocaml/quicktest/quicktest_vm_import_export.ml b/ocaml/quicktest/quicktest_vm_import_export.ml
index 1eb0c7833..7a533d1d3 100644
--- a/ocaml/quicktest/quicktest_vm_import_export.ml
+++ b/ocaml/quicktest/quicktest_vm_import_export.ml
@@ -46,13 +46,13 @@ let with_setup rpc session_id sr vm_template f =
         (Client.Client.VBD.create ~rpc ~session_id ~vM:vm ~vDI:Ref.null
            ~userdevice:"0" ~bootable:false ~mode:`RO ~_type:`CD
            ~unpluggable:true ~empty:true ~other_config:[] ~qos_algorithm_type:""
-           ~qos_algorithm_params:[]) ;
+           ~qos_algorithm_params:[] ~device:"" ~currently_attached:false) ;
       ignore
         (Client.Client.VBD.create ~rpc ~session_id ~vM:vm ~vDI:vdi
            ~userdevice:"1" ~bootable:false ~mode:`RW ~_type:`Disk
            ~unpluggable:true ~empty:false
            ~other_config:[(Constants.owner_key, "")]
-           ~qos_algorithm_type:"" ~qos_algorithm_params:[]) ;
+           ~qos_algorithm_type:"" ~qos_algorithm_params:[] ~device:"" ~currently_attached:false) ;
       f vm)

 let import_export_test rpc session_id sr_info vm_template () =
diff --git a/ocaml/tests/test_common.ml b/ocaml/tests/test_common.ml
index 18d96a2dd..766fb4486 100644
--- a/ocaml/tests/test_common.ml
+++ b/ocaml/tests/test_common.ml
@@ -140,10 +140,10 @@ let make_vm ~__context ?(name_label = "name_label")
     ?(tags = []) ?(blocked_operations = []) ?(protection_policy = Ref.null)
     ?(is_snapshot_from_vmpp = false) ?(appliance = Ref.null) ?(start_delay = 0L)
     ?(snapshot_schedule = Ref.null) ?(is_vmss_snapshot = false)
-    ?(shutdown_delay = 0L) ?(order = 0L) ?(suspend_SR = Ref.null)
+    ?(shutdown_delay = 0L) ?(order = 0L) ?(suspend_SR = Ref.null) ?(suspend_VDI=Ref.null)
     ?(version = 0L) ?(generation_id = "0:0") ?(hardware_platform_version = 0L)
     ?(has_vendor_device = false) ?(has_vendor_device = false)
-    ?(reference_label = "") ?(domain_type = `hvm) ?(nVRAM = []) () =
+    ?(reference_label = "") ?(domain_type = `hvm) ?(nVRAM = []) ?(last_booted_record="") ?(last_boot_CPU_flags=[]) ?(power_state=`Halted) () =
   Xapi_vm.create ~__context ~name_label ~name_description ~user_version
     ~is_a_template ~affinity ~memory_target ~memory_static_max
     ~memory_dynamic_max ~memory_dynamic_min ~memory_static_min ~vCPUs_params
@@ -153,9 +153,9 @@ let make_vm ~__context ?(name_label = "name_label")
     ~hVM_shadow_multiplier ~platform ~nVRAM ~pCI_bus ~other_config
     ~xenstore_data ~recommendations ~ha_always_run ~ha_restart_priority ~tags
     ~blocked_operations ~protection_policy ~is_snapshot_from_vmpp ~appliance
-    ~start_delay ~shutdown_delay ~order ~suspend_SR ~snapshot_schedule
+    ~start_delay ~shutdown_delay ~order ~suspend_SR ~suspend_VDI ~snapshot_schedule
     ~is_vmss_snapshot ~version ~generation_id ~hardware_platform_version
-    ~has_vendor_device ~reference_label ~domain_type
+    ~has_vendor_device ~reference_label ~domain_type ~last_booted_record ~last_boot_CPU_flags ~power_state

 let make_host ~__context ?(uuid = make_uuid ()) ?(name_label = "host")
     ?(name_description = "description") ?(hostname = "localhost")
diff --git a/ocaml/tests/test_vdi_cbt.ml b/ocaml/tests/test_vdi_cbt.ml
index 54dc49a96..65f07da9d 100644
--- a/ocaml/tests/test_vdi_cbt.ml
+++ b/ocaml/tests/test_vdi_cbt.ml
@@ -163,7 +163,7 @@ let test_vbd_create () =
     (fun () ->
       Xapi_vbd.create ~__context ~vM ~vDI ~userdevice:"autodetect"
         ~bootable:true ~mode:`RW ~_type:`Disk ~unpluggable:true ~empty:false
-        ~other_config:[] ~qos_algorithm_type:"" ~qos_algorithm_params:[]
+        ~other_config:[] ~qos_algorithm_type:"" ~qos_algorithm_params:[] ~device:"" ~currently_attached:false
       |> ignore)

 let test_get_nbd_info =
diff --git a/ocaml/xapi-cli-server/cli_operations.ml b/ocaml/xapi-cli-server/cli_operations.ml
index fb8fc626c..fd9fa2a25 100644
--- a/ocaml/xapi-cli-server/cli_operations.ml
+++ b/ocaml/xapi-cli-server/cli_operations.ml
@@ -216,7 +216,7 @@ let create_vbd_and_plug_with_other_config rpc session_id vm vdi device_name
   let vbd =
     Client.VBD.create ~rpc ~session_id ~vM:vm ~vDI:vdi ~userdevice:device_name
       ~bootable ~mode:rw ~_type:cd ~unpluggable ~empty:false
-      ~qos_algorithm_type:qtype ~qos_algorithm_params:qparams ~other_config
+      ~qos_algorithm_type:qtype ~qos_algorithm_params:qparams ~other_config ~device:"" ~currently_attached:false
   in
   try Client.VBD.plug rpc session_id vbd
   with Api_errors.Server_error (_, _) as e ->
@@ -2048,7 +2048,7 @@ let vbd_create printer rpc session_id params =
     Client.VBD.create ~rpc ~session_id ~vM ~vDI
       ~userdevice:(List.assoc "device" params)
       ~bootable ~mode ~_type ~unpluggable ~empty ~qos_algorithm_type:""
-      ~qos_algorithm_params:[] ~other_config:[]
+      ~qos_algorithm_params:[] ~other_config:[] ~device:"" ~currently_attached:false
   in
   let vbd_uuid = Client.VBD.get_uuid rpc session_id vbd in
   printer (Cli_printer.PList [vbd_uuid])
@@ -2366,7 +2366,7 @@ let vif_create printer rpc session_id params =
   let network = Client.Network.get_by_uuid rpc session_id network_uuid in
   let mtu = Client.Network.get_MTU rpc session_id network in
   let vif =
-    Client.VIF.create rpc session_id device network vm mac mtu [] "" []
+    Client.VIF.create rpc session_id device network vm mac mtu [] false "" []
       `network_default [] []
   in
   let uuid = Client.VIF.get_uuid rpc session_id vif in
@@ -2473,10 +2473,10 @@ let vm_create printer rpc session_id params =
       ~ha_always_run:false ~ha_restart_priority:"" ~tags:[]
       ~protection_policy:Ref.null ~is_snapshot_from_vmpp:false
       ~snapshot_schedule:Ref.null ~is_vmss_snapshot:false ~appliance:Ref.null
-      ~start_delay:0L ~shutdown_delay:0L ~order:0L ~suspend_SR:Ref.null
+      ~start_delay:0L ~shutdown_delay:0L ~order:0L ~suspend_SR:Ref.null ~suspend_VDI:Ref.null
       ~version:0L ~generation_id:"" ~hardware_platform_version:0L
       ~has_vendor_device:false ~reference_label:"" ~domain_type:`unspecified
-      ~nVRAM:[]
+      ~nVRAM:[] ~last_booted_record:"" ~last_boot_CPU_flags:[] ~power_state:`Halted
   in
   let uuid = Client.VM.get_uuid rpc session_id vm in
   printer (Cli_printer.PList [uuid])
diff --git a/ocaml/xapi/attach_helpers.ml b/ocaml/xapi/attach_helpers.ml
index ee3073b57..10248e0a0 100644
--- a/ocaml/xapi/attach_helpers.ml
+++ b/ocaml/xapi/attach_helpers.ml
@@ -97,6 +97,7 @@ let with_vbds rpc session_id __context vm vdis mode f =
               ~userdevice:"autodetect" ~bootable:false ~mode ~_type:`Disk
               ~unpluggable:true ~qos_algorithm_type:"" ~qos_algorithm_params:[]
               ~other_config:[(Xapi_globs.vbd_task_key, Ref.string_of task_id)]
+              ~device:"" ~currently_attached:false
           in
           (* sanity-check *)
           if has_vbd_leaked __context vbd then
diff --git a/ocaml/xapi/debug_populate.ml b/ocaml/xapi/debug_populate.ml
index 679e12ace..3aa8bbba8 100644
--- a/ocaml/xapi/debug_populate.ml
+++ b/ocaml/xapi/debug_populate.ml
@@ -87,7 +87,7 @@ let rec make_vdis_and_vbds __context vmref i =
       Xapi_vbd.create ~__context ~vM:vmref ~vDI:vdi
         ~userdevice:(string_of_int i) ~bootable:true ~mode:`RW ~_type:`Disk
         ~empty:false ~qos_algorithm_type:"" ~qos_algorithm_params:[]
-        ~other_config:[] ~unpluggable:false
+        ~other_config:[] ~unpluggable:false ~device:"" ~currently_attached:false
     in
     make_vdis_and_vbds __context vmref (i - 1)

@@ -100,7 +100,7 @@ let rec make_vifs __context vmref i =
          ~network:(get_random nws) ~vM:vmref ~mAC:"de:ad:be:ef:99:88"
          ~mTU:Int64.zero ~other_config:[] ~qos_algorithm_type:""
          ~qos_algorithm_params:[] ~locking_mode:`network_default
-         ~ipv4_allowed:[] ~ipv6_allowed:[]) ;
+         ~ipv4_allowed:[] ~ipv6_allowed:[] ~currently_attached:false) ;
     make_vifs __context vmref (i - 1)
   )

diff --git a/ocaml/xapi/import.ml b/ocaml/xapi/import.ml
index 10d7366ea..346ba8b40 100644
--- a/ocaml/xapi/import.ml
+++ b/ocaml/xapi/import.ml
@@ -1318,7 +1318,7 @@ module VBD : HandlerTools = struct
         let vbd =
           log_reraise "failed to create VBD"
             (fun value ->
-              let vbd = Client.VBD.create_from_record rpc session_id value in
+              let vbd = Client.VBD.create_from_record rpc session_id { value with API.vBD_device = ""; API.vBD_currently_attached = false } in
               if config.full_restore then
                 Db.VBD.set_uuid ~__context ~self:vbd ~value:value.API.vBD_uuid ;
               vbd)
@@ -1440,7 +1440,7 @@ module VIF : HandlerTools = struct
         let vif =
           log_reraise "failed to create VIF"
             (fun value ->
-              let vif = Client.VIF.create_from_record rpc session_id value in
+              let vif = Client.VIF.create_from_record rpc session_id { value with API.vIF_currently_attached = false } in
               if config.full_restore then
                 Db.VIF.set_uuid ~__context ~self:vif ~value:value.API.vIF_uuid ;
               vif)
diff --git a/ocaml/xapi/import_xva.ml b/ocaml/xapi/import_xva.ml
index 3df57b752..6d77d92a2 100644
--- a/ocaml/xapi/import_xva.ml
+++ b/ocaml/xapi/import_xva.ml
@@ -92,9 +92,10 @@ let make __context rpc session_id srid (vms, vdis) =
           ~tags:[] ~protection_policy:Ref.null ~is_snapshot_from_vmpp:false
           ~snapshot_schedule:Ref.null ~is_vmss_snapshot:false
           ~appliance:Ref.null ~start_delay:0L ~shutdown_delay:0L ~order:0L
-          ~suspend_SR:Ref.null ~version:0L ~generation_id:""
+          ~suspend_SR:Ref.null ~suspend_VDI:Ref.null ~version:0L ~generation_id:""
           ~hardware_platform_version:0L ~has_vendor_device:false
           ~reference_label:"" ~nVRAM:[]
+          ~last_booted_record:"" ~last_boot_CPU_flags:[] ~power_state:`Halted
       in
       TaskHelper.operate_on_db_task ~__context (fun task ->
           Client.VM.add_to_other_config ~rpc ~session_id ~self:vm_ref
@@ -126,7 +127,7 @@ let make __context rpc session_id srid (vms, vdis) =
               ~userdevice:vbd.device ~bootable:(vbd.funct = Root) ~mode:vbd.mode
               ~_type:`Disk ~empty:false
               ~unpluggable:(vbd.vdi.variety <> `system)
-              ~qos_algorithm_type:"" ~qos_algorithm_params:[]
+              ~qos_algorithm_type:"" ~qos_algorithm_params:[] ~device:"" ~currently_attached:false
           in
           clean_up_stack :=
             (fun __context rpc session_id ->
@@ -139,7 +140,7 @@ let make __context rpc session_id srid (vms, vdis) =
             (Client.VBD.create ~rpc ~session_id ~vM:vm_ref ~vDI:Ref.null
                ~other_config:[] ~userdevice:"autodetect" ~bootable:false
                ~mode:`RO ~_type:`CD ~unpluggable:true ~empty:true
-               ~qos_algorithm_type:"" ~qos_algorithm_params:[])
+               ~qos_algorithm_type:"" ~qos_algorithm_params:[] ~device:"" ~currently_attached:false )
         with e ->
           warn "could not create CD drive on imported XVA: %s"
             (Printexc.to_string e)
diff --git a/ocaml/xapi/message_forwarding.ml b/ocaml/xapi/message_forwarding.ml
index c49fde6ba..e6cf79e0b 100644
--- a/ocaml/xapi/message_forwarding.ml
+++ b/ocaml/xapi/message_forwarding.ml
@@ -3574,11 +3574,11 @@ functor

       (* -------------------------------------------------------------------------- *)

-      let create ~__context ~device ~network ~vM ~mAC ~mTU ~other_config
+      let create ~__context ~device ~network ~vM ~mAC ~mTU ~other_config ~currently_attached
           ~qos_algorithm_type ~qos_algorithm_params =
         info "VIF.create: VM = '%s'; network = '%s'" (vm_uuid ~__context vM)
           (network_uuid ~__context network) ;
-        Local.VIF.create ~__context ~device ~network ~vM ~mAC ~mTU ~other_config
+        Local.VIF.create ~__context ~device ~network ~vM ~mAC ~mTU ~other_config ~currently_attached
           ~qos_algorithm_type ~qos_algorithm_params

       let destroy ~__context ~self =
@@ -4790,14 +4790,14 @@ functor
       (* -------------------------------------------------------------------------- *)

       (* these are db functions *)
-      let create ~__context ~vM ~vDI ~userdevice ~bootable ~mode ~_type
-          ~unpluggable ~empty ~other_config ~qos_algorithm_type
+      let create ~__context ~vM ~vDI ~device ~userdevice ~bootable ~mode ~_type
+          ~unpluggable ~empty ~other_config ~currently_attached ~qos_algorithm_type
           ~qos_algorithm_params =
         info "VBD.create: VM = '%s'; VDI = '%s'" (vm_uuid ~__context vM)
           (vdi_uuid ~__context vDI) ;
         (* NB must always execute this on the master because of the autodetect_mutex *)
-        Local.VBD.create ~__context ~vM ~vDI ~userdevice ~bootable ~mode ~_type
-          ~unpluggable ~empty ~other_config ~qos_algorithm_type
+        Local.VBD.create ~__context ~vM ~vDI ~device ~userdevice ~bootable ~mode ~_type
+          ~unpluggable ~empty ~other_config ~currently_attached ~qos_algorithm_type
           ~qos_algorithm_params

       let set_mode ~__context ~self ~value =
diff --git a/ocaml/xapi/xapi_pool_update.ml b/ocaml/xapi/xapi_pool_update.ml
index 1ad43e822..5de62a1fc 100644
--- a/ocaml/xapi/xapi_pool_update.ml
+++ b/ocaml/xapi/xapi_pool_update.ml
@@ -263,7 +263,7 @@ let attach_helper ~__context ~uuid ~vdi ~use_localhost_proxy =
               Client.VBD.create ~rpc ~session_id ~vM:dom0 ~empty:false ~vDI:vdi
                 ~userdevice:"autodetect" ~bootable:false ~mode:`RO ~_type:`Disk
                 ~unpluggable:true ~qos_algorithm_type:""
-                ~qos_algorithm_params:[] ~other_config:[]
+                ~qos_algorithm_params:[] ~other_config:[] ~device:"" ~currently_attached:false
             in
             Client.VBD.plug ~rpc ~session_id ~self:vbd ;
             "/dev/" ^ Client.VBD.get_device ~rpc ~session_id ~self:vbd)
diff --git a/ocaml/xapi/xapi_templates.ml b/ocaml/xapi/xapi_templates.ml
index 9e7b36fd2..7aaba3142 100644
--- a/ocaml/xapi/xapi_templates.ml
+++ b/ocaml/xapi/xapi_templates.ml
@@ -147,7 +147,7 @@ let create_disk rpc session_id vm sm_config disk =
       ~bootable:disk.bootable ~mode:`RW ~_type:`Disk
       ~unpluggable:(disk._type <> `system)
       ~empty:false ~qos_algorithm_type:"" ~qos_algorithm_params:[]
-      ~other_config:[(Constants.owner_key, "")]
+      ~other_config:[(Constants.owner_key, "")] ~device:"" ~currently_attached:false
   in
   let device = Client.VBD.get_userdevice ~rpc ~session_id ~self:vbd_ref in
   Client.VDI.set_name_label ~rpc ~session_id ~self:vdi ~value:device ;
diff --git c/ocaml/xapi/xapi_vbd.ml w/ocaml/xapi/xapi_vbd.ml
index 7986fe702..94aa36ba7 100644
--- c/ocaml/xapi/xapi_vbd.ml
+++ w/ocaml/xapi/xapi_vbd.ml
@@ -167,9 +167,19 @@ let unplug_force_no_safety_check = unplug_force
 let autodetect_mutex = Mutex.create ()

 (** VBD.create doesn't require any interaction with xen *)
-let create ~__context ~vM ~vDI ~userdevice ~bootable ~mode ~_type ~unpluggable
-    ~empty ~other_config ~qos_algorithm_type ~qos_algorithm_params =
-  ( if not empty then
+let create ~__context ~vM ~vDI ~device ~userdevice ~bootable ~mode ~_type ~unpluggable
+     ~empty ~other_config ~currently_attached ~qos_algorithm_type ~qos_algorithm_params =
+  (* TODO: Raise bad power state error (once all API clients make sure to onlu call the needed params in the create method) when:
+    - power_state == `Halted and (device <> "" || currently_attached)
+  *)
+
+  let power_state = Db.VM.get_power_state ~__context ~self:vM in
+  let suspended = (power_state = `Suspended) in
+  let _device = if suspended then device else "" in
+  let _currently_attached = if suspended then currently_attached else false in
+
+  (
+    if not empty then
       let vdi_type = Db.VDI.get_type ~__context ~self:vDI in
       if
         not
@@ -287,9 +297,9 @@ let create ~__context ~vM ~vDI ~userdevice ~bootable ~mode ~_type ~unpluggable
           in
           Db.VBD.create ~__context ~ref ~uuid:(Uuid.to_string uuid)
             ~current_operations:[] ~allowed_operations:[] ~storage_lock:false
-            ~vM ~vDI ~userdevice ~device:"" ~bootable ~mode ~_type ~unpluggable
+            ~vM ~vDI ~userdevice ~device:_device ~bootable ~mode ~_type ~unpluggable
             ~empty ~reserved:false ~qos_algorithm_type ~qos_algorithm_params
-            ~qos_supported_algorithms:[] ~currently_attached:false
+            ~qos_supported_algorithms:[] ~currently_attached:_currently_attached
             ~status_code:Int64.zero ~status_detail:"" ~runtime_properties:[]
             ~other_config ~metrics ;
           update_allowed_operations ~__context ~self:ref ;
diff --git a/ocaml/xapi/xapi_vdi_helpers.ml b/ocaml/xapi/xapi_vdi_helpers.ml
index e3557ac84..1962a6b48 100644
--- a/ocaml/xapi/xapi_vdi_helpers.ml
+++ b/ocaml/xapi/xapi_vdi_helpers.ml
@@ -114,7 +114,7 @@ let enable_database_replication ~__context ~get_vdi_callback =
                 Client.VBD.create ~rpc ~session_id ~vM:dom0 ~empty:false
                   ~vDI:vdi ~userdevice:"autodetect" ~bootable:false ~mode:`RW
                   ~_type:`Disk ~unpluggable:true ~qos_algorithm_type:""
-                  ~qos_algorithm_params:[] ~other_config:[]
+                  ~qos_algorithm_params:[] ~other_config:[] ~device:"" ~currently_attached:false
               in
               Client.VBD.plug ~rpc ~session_id ~self:vbd ;
               vbd)
diff --git a/ocaml/xapi/xapi_vif.ml b/ocaml/xapi/xapi_vif.ml
index 548614427..1f855d305 100644
--- a/ocaml/xapi/xapi_vif.ml
+++ b/ocaml/xapi/xapi_vif.ml
@@ -32,10 +32,19 @@ let unplug ~__context ~self = Xapi_xenops.vif_unplug ~__context ~self false

 let unplug_force ~__context ~self = Xapi_xenops.vif_unplug ~__context ~self true

-let create ~__context ~device ~network ~vM ~mAC ~mTU ~other_config
+let create ~__context ~device ~network ~vM ~mAC ~mTU ~other_config  ~currently_attached
     ~qos_algorithm_type ~qos_algorithm_params ~locking_mode ~ipv4_allowed
     ~ipv6_allowed : API.ref_VIF =
-  create ~__context ~device ~network ~vM ~currently_attached:false ~mAC ~mTU
+
+  (* TODO: Raise bad power state error (once all API clients make sure to onlu call the needed params in the create method) when:
+    - power_state == `Halted and currently_attached = true
+  *)
+
+  let power_state = Db.VM.get_power_state ~__context ~self:vM in
+  let suspended = (power_state = `Suspended) in
+  let _currently_attached = if suspended then currently_attached else false in
+
+  create ~__context ~device ~network ~vM ~currently_attached:_currently_attached ~mAC ~mTU
     ~other_config ~qos_algorithm_type ~qos_algorithm_params ~locking_mode
     ~ipv4_allowed ~ipv6_allowed ~ipv4_configuration_mode:`None
     ~ipv4_addresses:[] ~ipv4_gateway:"" ~ipv6_configuration_mode:`None
diff --git a/ocaml/xapi/xapi_vif.mli b/ocaml/xapi/xapi_vif.mli
index 05a4f167b..782bab119 100644
--- a/ocaml/xapi/xapi_vif.mli
+++ b/ocaml/xapi/xapi_vif.mli
@@ -48,6 +48,7 @@ val create :
   -> mAC:string
   -> mTU:int64
   -> other_config:(string * string) list
+  -> currently_attached:bool
   -> qos_algorithm_type:string
   -> qos_algorithm_params:(string * string) list
   -> locking_mode:API.vif_locking_mode
diff --git a/ocaml/xapi/xapi_vm.ml b/ocaml/xapi/xapi_vm.ml
index 2e5ed9d5b..025aa3e85 100644
--- a/ocaml/xapi/xapi_vm.ml
+++ b/ocaml/xapi/xapi_vm.ml
@@ -590,18 +590,19 @@ let resume_on ~__context ~vm ~host ~start_paused ~force =
   assert_host_is_localhost ~__context ~host ;
   resume ~__context ~vm ~start_paused ~force

-let create ~__context ~name_label ~name_description ~user_version ~is_a_template
+let create ~__context ~name_label ~name_description ~power_state ~user_version ~is_a_template ~suspend_VDI
     ~affinity ~memory_target ~memory_static_max ~memory_dynamic_max
     ~memory_dynamic_min ~memory_static_min ~vCPUs_params ~vCPUs_max
     ~vCPUs_at_startup ~actions_after_shutdown ~actions_after_reboot
     ~actions_after_crash ~pV_bootloader ~pV_kernel ~pV_ramdisk ~pV_args
     ~pV_bootloader_args ~pV_legacy_args ~hVM_boot_policy ~hVM_boot_params
-    ~hVM_shadow_multiplier ~platform ~pCI_bus ~other_config ~recommendations
+    ~hVM_shadow_multiplier ~platform ~pCI_bus ~other_config ~last_boot_CPU_flags ~last_booted_record ~recommendations
     ~xenstore_data ~ha_always_run ~ha_restart_priority ~tags ~blocked_operations
     ~protection_policy ~is_snapshot_from_vmpp ~snapshot_schedule
     ~is_vmss_snapshot ~appliance ~start_delay ~shutdown_delay ~order ~suspend_SR
     ~version ~generation_id ~hardware_platform_version ~has_vendor_device
     ~reference_label ~domain_type ~nVRAM : API.ref_VM =
+
   if has_vendor_device then
     Pool_features.assert_enabled ~__context
       ~f:Features.PCI_device_for_auto_update ;
@@ -618,23 +619,47 @@ let create ~__context ~name_label ~name_description ~user_version ~is_a_template
   let vm_ref = Ref.make () in
   let resident_on = Ref.null in
   let scheduled_to_be_resident_on = Ref.null in
+  (* TODO: Raise bad power state error (once all API clients make sure to only call the needed params in the create method) when:
+    - power_state == `Halted and suspend_VDI <> Ref.null
+    - power_state == `Suspended and suspend_VDI = Ref.null || last_booted_record = "" || last_boot_CPU_flags = []
+    - power_state not in [`Halted, `Suspended]
+  *)
+
   let metrics = Ref.make ()
   and metrics_uuid = Uuid.to_string (Uuid.make_uuid ()) in
   let vCPUs_utilisation = [(0L, 0.)] in
+  let suspended = (power_state = `Suspended) in
+  let current_domain_type = if suspended then domain_type else `unspecified in
   Db.VM_metrics.create ~__context ~ref:metrics ~uuid:metrics_uuid
     ~memory_actual:0L ~vCPUs_number:0L ~vCPUs_utilisation ~vCPUs_CPU:[]
     ~vCPUs_params:[] ~vCPUs_flags:[] ~state:[] ~start_time:Date.never
     ~install_time:Date.never ~last_updated:Date.never ~other_config:[]
     ~hvm:false ~nested_virt:false ~nomigrate:false
-    ~current_domain_type:`unspecified ;
+    ~current_domain_type ;
   let domain_type =
     if domain_type = `unspecified then
       derive_domain_type ~hVM_boot_policy
     else
       domain_type
   in
+  let _last_booted_record = if suspended then last_booted_record else "" in
+  let _last_boot_CPU_flags = if suspended then last_boot_CPU_flags else [] in
+  let _power_state = if suspended then `Suspended else `Halted in
+  let _suspend_VDI = if suspended then suspend_VDI else Ref.null in
+
+  if suspended && (
+    _last_boot_CPU_flags = [] ||
+    _last_booted_record = "" ||
+    _suspend_VDI = Ref.null
+  ) then begin
+    raise (Api_errors.(Server_error (vm_bad_power_state, [
+        Ref.string_of vm_ref;
+        Record_util.power_to_string `Halted;
+        Record_util.power_to_string power_state
+      ])))
+  end;
   Db.VM.create ~__context ~ref:vm_ref ~uuid:(Uuid.to_string uuid)
-    ~power_state:`Halted ~allowed_operations:[] ~current_operations:[]
+    ~power_state:_power_state ~allowed_operations:[] ~current_operations:[]
     ~blocked_operations:[] ~name_label ~name_description ~user_version
     ~is_a_template ~is_default_template:false ~transportable_snapshot_id:""
     ~is_a_snapshot:false ~snapshot_time:Date.never ~snapshot_of:Ref.null
@@ -644,17 +669,16 @@ let create ~__context ~name_label ~name_description ~user_version ~is_a_template
     ~memory_static_min ~vCPUs_params ~vCPUs_at_startup ~vCPUs_max
     ~actions_after_shutdown ~actions_after_reboot ~actions_after_crash
     ~hVM_boot_policy ~hVM_boot_params ~hVM_shadow_multiplier
-    ~suspend_VDI:Ref.null ~platform ~nVRAM ~pV_kernel ~pV_ramdisk ~pV_args
+    ~suspend_VDI:_suspend_VDI ~platform ~nVRAM ~pV_kernel ~pV_ramdisk ~pV_args
     ~pV_bootloader ~pV_bootloader_args ~pV_legacy_args ~pCI_bus ~other_config
-    ~domid:(-1L) ~domarch:"" ~last_boot_CPU_flags:[] ~is_control_domain:false
-    ~metrics ~guest_metrics:Ref.null ~last_booted_record:"" ~xenstore_data
+    ~domid:(-1L) ~domarch:"" ~last_boot_CPU_flags:_last_boot_CPU_flags ~is_control_domain:false
+    ~metrics ~guest_metrics:Ref.null ~last_booted_record:_last_booted_record ~xenstore_data
     ~recommendations ~blobs:[] ~ha_restart_priority ~ha_always_run ~tags
     ~bios_strings:[] ~protection_policy:Ref.null ~is_snapshot_from_vmpp:false
     ~snapshot_schedule:Ref.null ~is_vmss_snapshot:false ~appliance ~start_delay
     ~shutdown_delay ~order ~suspend_SR ~version ~generation_id
     ~hardware_platform_version ~has_vendor_device ~requires_reboot:false
     ~reference_label ~domain_type ;
-  Db.VM.set_power_state ~__context ~self:vm_ref ~value:`Halted ;
   Xapi_vm_lifecycle.update_allowed_operations ~__context ~self:vm_ref ;
   update_memory_overhead ~__context ~vm:vm_ref ;
   update_vm_virtual_hardware_platform_version ~__context ~vm:vm_ref ;
diff --git a/ocaml/xapi/xapi_vm.mli b/ocaml/xapi/xapi_vm.mli
index a54ec06be..ae997dab5 100644
--- a/ocaml/xapi/xapi_vm.mli
+++ b/ocaml/xapi/xapi_vm.mli
@@ -145,8 +145,10 @@ val create :
      __context:Context.t
   -> name_label:string
   -> name_description:string
+  -> power_state:API.vm_power_state
   -> user_version:int64
   -> is_a_template:bool
+  -> suspend_VDI:API.ref_VDI
   -> affinity:[`host] Ref.t
   -> memory_target:int64
   -> memory_static_max:int64
@@ -177,6 +179,8 @@ val create :
   -> platform:(string * string) list
   -> pCI_bus:string
   -> other_config:(string * string) list
+  -> last_boot_CPU_flags:(string * string) list
+  -> last_booted_record:string
   -> recommendations:string
   -> xenstore_data:(string * string) list
   -> ha_always_run:bool
diff --git a/ocaml/xapi/xapi_vm_helpers.ml b/ocaml/xapi/xapi_vm_helpers.ml
index 7206a8bf2..adc0b2764 100644
--- a/ocaml/xapi/xapi_vm_helpers.ml
+++ b/ocaml/xapi/xapi_vm_helpers.ml
@@ -149,7 +149,7 @@ let update_vm_virtual_hardware_platform_version ~__context ~vm =

 let create_from_record_without_checking_licence_feature_for_vendor_device
     ~__context rpc session_id vm_record =
-  let mk_vm r = Client.Client.VM.create_from_record rpc session_id r in
+  let mk_vm r = Client.Client.VM.create_from_record rpc session_id { r with API.vM_suspend_VDI = Ref.null ; API.vM_power_state = `Halted } in
   let has_vendor_device = vm_record.API.vM_has_vendor_device in
   if
     has_vendor_device
