From ad8d0a6c258b700f73a4ae9af302a86b9ee06ac3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Edwin=20T=C3=B6r=C3=B6k?= <edwin.torok@cloud.com>
Date: Thu, 8 May 2025 21:34:18 +0100
Subject: [PATCH] [prepare]: make StringPool share safer
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

So we can call this from more generic code, without worrying whether locks are held.
Skip adding to the stringpool when locks aren't held and we can't obtain an atomic lock either.

No functional change

Signed-off-by: Edwin Török <edwin.torok@cloud.com>
---
 ocaml/database/db_cache_types.ml  | 39 ++++++++++++++++++++++++-------
 ocaml/database/db_cache_types.mli | 11 +++++++++
 2 files changed, 42 insertions(+), 8 deletions(-)

diff --git a/ocaml/database/db_cache_types.ml b/ocaml/database/db_cache_types.ml
index be73b9195..f258347ed 100644
--- a/ocaml/database/db_cache_types.ml
+++ b/ocaml/database/db_cache_types.ml
@@ -24,11 +24,33 @@ module HashedString = struct
   let hash = Hashtbl.hash
 end
 
-module StringPool = Weak.Make (HashedString)
+module Share : sig
+  val merge : string -> string
+  (** [merge str] merges [str] into the stringpool.
+    It returns a string equal to [str].
 
-let share =
-  let pool = StringPool.create 2048 in
-  StringPool.merge pool
+    This function is thread-safe, it skips adding the string to the pool
+    when called concurrently.
+    For best results call this while holding another lock.
+   *)
+end = struct
+  module StringPool = Weak.Make (HashedString)
+
+  let pool = StringPool.create 2048
+
+  let merge_running = Atomic.make 0
+
+  let merge str =
+    let str =
+      if Atomic.fetch_and_add merge_running 1 = 0 then
+        StringPool.merge pool str
+      else
+        (* no point in using a mutex here, just fall back to not sharing,
+           which is quicker. *)
+        str
+    in
+    Atomic.decr merge_running ; str
+end
 
 module Stat = struct
   type t = {created: Time.t; modified: Time.t; deleted: Time.t}
@@ -45,7 +67,7 @@ module StringMap = struct
     let compare = String.compare
   end)
 
-  let add key v t = add (share key) v t
+  let add key v t = add (Share.merge key) v t
 end
 
 module type VAL = sig
@@ -143,11 +165,12 @@ module Row = struct
     @@
     match v with
     | Schema.Value.String x ->
-        Schema.Value.String (share x)
+        Schema.Value.String (Share.merge x)
     | Schema.Value.Pairs ps ->
-        Schema.Value.Pairs (List.map (fun (x, y) -> (share x, share y)) ps)
+        Schema.Value.Pairs
+          (List.map (fun (x, y) -> (Share.merge x, Share.merge y)) ps)
     | Schema.Value.Set xs ->
-        Schema.Value.Set (List.map share xs)
+        Schema.Value.Set (List.map Share.merge xs)
 
   type t = map_t
 
diff --git a/ocaml/database/db_cache_types.mli b/ocaml/database/db_cache_types.mli
index 2ffe79c41..4d0908c28 100644
--- a/ocaml/database/db_cache_types.mli
+++ b/ocaml/database/db_cache_types.mli
@@ -79,6 +79,17 @@ module type MAP = sig
       On exit there will be a binding of [key] whose modification time is [now] *)
 end
 
+module Share : sig
+  val merge : string -> string
+  (** [merge str] merges [str] into the stringpool.
+    It returns a string equal to [str].
+
+    This function is thread-safe, it skips adding the string to the pool
+    when called concurrently.
+    For best results call this while holding another lock.
+   *)
+end
+
 module Row : sig
   include MAP with type value = Schema.Value.t
 
