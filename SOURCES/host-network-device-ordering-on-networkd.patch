diff --git a/doc/content/xcp-networkd/host-network-device-ordering-on-networkd.md b/doc/content/xcp-networkd/host-network-device-ordering-on-networkd.md
new file mode 100644
index 000000000..e142932d1
--- /dev/null
+++ b/doc/content/xcp-networkd/host-network-device-ordering-on-networkd.md
@@ -0,0 +1,342 @@
+---
+title: Host Network Device Ordering on Networkd
+description: How does the host network device ordering work on networkd.
+---
+
+Purpose
+-------
+
+One of the Toolstack's functions is to maintain a pool of hosts. A pool can be
+constructed by joining a host into an existing pool. One challenge in this
+process is determining which pool-wide network a network device on the joining
+host should connect to.
+
+At first glance, this could be resolved by specifying a mapping between an
+individual network device and a pool-wide network. However, this approach
+would be burdensome for administrators when managing many hosts. It would be
+more efficient if the Toolstack could determine this automatically.
+
+To achieve this, the Toolstack components on two hosts need to independently
+work out consistent identifications for the host network devices and connect
+the network devices with the same identification to the same pool-wide network.
+The identifications on a host can be considered as an order, with each network
+device assigned a unique position in the order as its identification. Network
+devices with the same position will connect to the same network.
+
+
+The assumption
+--------------
+
+Why can the Toolstack components on two hosts independently work out an expected
+order without any communication? This is possible only under the assumption that
+the hosts have identical hardware, firmware, software, and the way
+network devices are plugged into them. For example, an administrator will always
+plug the network devices into the same PCI slot position on multiple hosts if
+they want these network devices to connect to the same network.
+
+The ordering is considered consistent if the positions of such network devices
+(plugged into the same PCI slot position) in the generated orders are the same.
+
+
+The biosdevname
+---------------
+Particularly, when the assumption above holds, a consistent initial order can be
+worked out on multiple hosts independently with the help of `biosdevname`. The
+"all_ethN" policy of the `biosdevname` utility can generate a device order based
+on whether the device is embedded or not, PCI cards in ascending slot order, and
+ports in ascending PCI bus/device/function order breadth-first. Since the hosts
+are identical, the orders generated by the `biosdevname` are consistent across
+the hosts.
+
+An example of `biosdevname`'s output is as the following. The initial order can
+be derived from the `BIOS device` field.
+
+```
+# biosdevname --policy all_ethN -d -x
+BIOS device: eth0
+Kernel name: enp5s0
+Permanent MAC: 00:02:C9:ED:FD:F0
+Assigned MAC : 00:02:C9:ED:FD:F0
+Bus Info: 0000:05:00.0
+...
+
+BIOS device: eth1
+Kernel name: enp5s1
+Permanent MAC: 00:02:C9:ED:FD:F1
+Assigned MAC : 00:02:C9:ED:FD:F1
+Bus Info: 0000:05:01.0
+...
+```
+
+However, the `BIOS device` of a particular network device may change with the
+addition or removal of devices. For example:
+
+```
+# biosdevname --policy all_ethN -d -x
+BIOS device: eth0
+Kernel name: enp4s0
+Permanent MAC: EC:F4:BB:E6:D7:BB
+Assigned MAC : EC:F4:BB:E6:D7:BB
+Bus Info: 0000:04:00.0
+...
+
+BIOS device: eth1
+Kernel name: enp5s0
+Permanent MAC: 00:02:C9:ED:FD:F0
+Assigned MAC : 00:02:C9:ED:FD:F0
+Bus Info: 0000:05:00.0
+...
+
+BIOS device: eth2
+Kernel name: enp5s1
+Permanent MAC: 00:02:C9:ED:FD:F1
+Assigned MAC : 00:02:C9:ED:FD:F1
+Bus Info: 0000:05:01.0
+...
+```
+
+Therefore, the order derived from these values is used solely for determining
+the initial order and the order of newly added devices.
+
+Principles
+-----------
+* Initially, the order is aligned with PCI slots. This is to make the connection
+between cabling and order predictable: The network devices in identical PCI
+slots have the same position. The rationale is that PCI slots are more
+predictable than MAC addresses and correspond to physical locations.
+
+* Once a previous order has been established, the ordering should be maintained
+as stable as possible despite changes to MAC addresses or PCI addresses. The
+rationale is that the assumption is less likely to hold as long as the hosts are
+experiencing updates and maintenance. Therefore, maintaining the stable order is
+the best choice for automatic ordering.
+
+Notation
+--------
+
+```
+mac:pci:position
+!mac:pci:position
+```
+
+A network device is characterised by
+
+* MAC address, which is unique.
+* PCI slot, which is not unique and multiple network devices can share a PCI
+slot. PCI addresses correspond to hardware PCI slots and thus are physically
+observable.
+* position, the position assigned to this network device by xcp-networkd. At any
+given time, no position is assigned twice but the sequence of positions may have
+holes.
+* The `!mac:pci:position` notation indicates that this postion was previously
+used but currently is free because the device it was assgined was removed.
+
+On a Linux system, MAC and PCI addresses have specific formats. However, for
+simplicity, symbolic names are used here: MAC addresses use lowercase letters,
+PCI addresses use uppercase letters, and positions use numbers.
+
+Scenarios
+---------
+
+### The initial order
+
+As mentioned above, the `biosdevname` can be used to generate consistent orders
+for the network devices on multiple hosts.
+
+```
+current input: a:A   b:D   c:C
+initial order: a:A:0 c:C:1 b:D:2
+```
+
+This only works if the assumption of identical hardware, firmware, software, and
+network device placement holds. And it is considered that the assumption will
+hold for the majority of the use cases.
+
+Otherwise, the order can be generated from a user's configuration. The user can
+specify the order explicilty for individual hosts. However, administrators would
+prefer to avoid this as much as possible when managing many hosts.
+
+```
+user spec:     a::0  c::1  b::2
+current input: a:A   b:D   c:C
+initial order: a:A:0 c:C:1 b:D:2
+```
+
+### Keep the order as stable as possible
+
+Once an initial order is created on an individual host, it should be kept as
+stable as possible across host boot-ups and at runtime. For example, unless
+there are hardware changes, the position of a network device in the initial
+order should remain the same regardless of how many times the host is rebooted.
+
+To achieve this, the initial order should be saved persistently on the host's
+local storage so it can be referenced in subsequent orderings. When performing
+another ordering after the initial order has been saved, the position of a
+currently unordered network device should be determined by finding its position
+in the last saved order. The MAC address of the network device is a reliable
+attribute for this purpose, as it is considered unique for each network device
+globally.
+
+Therefore, the network devices in the saved order should have their MAC
+addresses saved together, effectively mapping each position to a MAC address.
+When performing an ordering, the stable position can be found by searching the
+last saved order using the MAC address.
+
+```
+last order:    a:A:0  c:C:1  b:D:2
+current input: a:A    b:D    c:C
+new order:     a:A:0  c:C:1  b:D:2
+```
+
+Name labels of the network devices are not considered reliable enough to
+identify particular devices. For example, if the name labels are determined by
+the PCI address via systemd, and a firmware update changes the PCI addresses of
+the network devices, the name labels will also change.
+
+The PCI addresses are not considered reliable as well. They may change due to
+the firmeware update/setting changes or even plugging/unpluggig other devices.
+
+```
+last order:    a:A:0  c:C:1  b:D:2
+current input: a:A    b:B    c:E
+new order:     a:A:0  c:E:1  b:B:2
+```
+
+### Replacement
+
+However, what happens when the MAC address of an unordered network device cannot
+be found in the last saved order? There are two possible scenarios:
+
+1. It's a newly added network device since the last ordering.
+2. It's a new device that replaces an existing network device.
+
+Replacement is a supported scenario, as an administrator might replace a broken
+network device with a new one.
+
+This can be recognized by comparing the PCI address where the network device is
+located. Therefore, the PCI address of each network device should also be saved
+in the order. In this case, searching the PCI address in the order results in
+one of the following:
+
+1. Not found: This means the PCI address was not occupied during the last
+ordering, indicating a newly added network device.
+2. Found with a MAC address, but another device with this MAC address is still
+present in the system: This suggests that the PCI address of an existing
+network device (with the same MAC address) has changed since the last ordering.
+This may be caused by either a device move or others like a firmware update. In
+this case, the current unordered network device is considered newly added.
+
+```
+last order:    a:A:0  c:C:1  b:D:2
+current input: a:A    b:B    c:C    d:D
+new order:     a:A:0  c:C:1  b:B:2  d:D:3
+```
+
+3. Found with a MAC address, and no current devices have this MAC address: This
+indicates that a new network device has replaced the old one in the same PCI
+slot.
+The replacing network device should be assigned the same position as the
+replaced one.
+
+```
+last order:    a:A:0  c:C:1  b:D:2
+current input: a:A    c:C    d:D
+new order:     a:A:0  c:C:1  d:D:2
+```
+
+### Removed devices
+
+A network device can be removed or unplugged since the last ordering. Its
+position, MAC address, and PCI address are saved for future reference, and its
+position will be reserved. This means there may be a gap in the order: a
+position that was previously assigned to a network device is now vacant because
+the device has been removed.
+
+```
+last order:    a:A:0  c:C:1  b:D:2
+current input: a:A    b:D
+new order:     a:A:0  !c:C:1 d:D:2
+```
+
+### Newly added devices
+
+As long as `the assumption` holds, newly added devices since the last ordering
+can be assigned positions consistently across multiple hosts. Newly added
+devices will not be assigned the positions reserved for removed devices.
+
+```
+last order:    a:A:0 !c:C:1  d:D:2
+current input: a:A           d:D    e:E
+new order:     a:A:0 !c:C:1  d:D:2  e:E:3
+```
+
+### Removed and then added back
+
+It is a supported scenario for a removed device to be plugged back in,
+regardless of whether it is in the same PCI slot or not. This can be recognized
+by searching for the device in the saved removed devices using its MAC address.
+The reserved position will be reassigned to the device when it is added back.
+
+```
+last order:    a:A:0 !c:C:1 d:D:2
+current input: a:A   c:F    d:D   e:E
+new order:     a:A:0 c:F:1  d:D:2 e:E:3
+```
+
+### Multinic functions
+
+The multinic function is a special kind of network device. When this type of
+physical device is plugged into a PCI slot, multiple network devices are
+reported at a single PCI address. Additionally, the number of reported network
+devices may change due to driver updates.
+
+```
+current input: a:A b:A c:A d:A
+initial order: a:A:0 b:A:1 c:A:2 d:A:3
+```
+
+As long as `the assumption` holds, the initial order of these devices can be
+generated automatically and kept stable by using MAC addresses to identify
+individual devices. However, `biosdevname` cannot reliably generate an order for
+all devices reported at one PCI address. For devices located at the same PCI
+address, their MAC addresses are used to generate the initial order.
+
+```
+last order:    a:A:0 b:A:1 c:A:2 d:A:3 m:M:4 n:N:5
+current input: a:A   b:A   c:A   d:A   e:A   f:A   m:M   n:N
+new order:     a:A:0 b:A:1 c:A:2 d:A:3 m:M:4 n:N:5 e:A:6 f:A:7
+```
+
+For example, suppose `biosdevname` generates an order for a multinic function
+and other non-multinic devices. Within this order, the N devices of the
+multinic function with MAC addresses mac[1], ..., mac[N] are assigned positions
+pos[1], ..., pos[N] correspondingly. `biosdevname` cannot ensure that the device
+with mac[1] is always assigned position pos[1]. Instead, it ensures that the
+entire set of positions pos[1], ..., pos[N] remains stable for the devices of
+the multinic function. Therefore, to ensure the order follows the MAC address
+order, the devices of the multinic function need to be sorted by their MAC
+addresses within the set of positions.
+
+```
+last order:    a:A:0 b:A:1 c:A:2 d:A:3 m:M:4
+current input: e:A   f:A   g:A   h:A   m:M
+new order:     e:A:0 f:A:1 g:A:2 h:A:3 m:M:4
+```
+
+Rare cases that can not be handled automatically
+------------------------------------------------
+
+In summary, to keep the order stable, the auto-generated order needs to be saved
+for the next ordering. When performing an automatic ordering for the current
+network devices, either the MAC address or the PCI address is used to recognize
+the device that was assigned the same position in the last ordering. If neither
+the MAC address nor the PCI address can be used to find a position from the last
+ordering, the device is considered newly added and is assigned a new position.
+
+However, following this sorting logic, the ordering result may not always be as
+expected. In practice, this can be caused by various rare cases, such as
+switching an existing network device to connect to another network, performing
+firmware updates, changing firmware settings, or plugging/unplugging network
+devices. It is not worth complicating the entire function for these rare cases.
+Instead, the initial user's configuration can be used to handle these rare
+scenarios.
diff --git a/ocaml/networkd/bin/network_monitor_thread.ml b/ocaml/networkd/bin/network_monitor_thread.ml
index 1b15dbe2a..d5ef8052d 100644
--- a/ocaml/networkd/bin/network_monitor_thread.ml
+++ b/ocaml/networkd/bin/network_monitor_thread.ml
@@ -26,10 +26,7 @@ let bonds_status : (string, int * int) Hashtbl.t = Hashtbl.create 10
 
 let monitor_whitelist =
   ref
-    [
-      "eth"
-    ; "vif" (* This includes "tap" owing to the use of standardise_name below *)
-    ]
+    ["vif" (* This includes "tap" owing to the use of standardise_name below *)]
 
 let rpc xml =
   let open Xmlrpc_client in
@@ -108,7 +105,10 @@ let standardise_name name =
     newname
   with _ -> name
 
-let get_link_stats () =
+let get_link_stats dbg () =
+  let managed_host_net_devs =
+    Network_server.Interface.get_interface_positions dbg () |> List.map fst
+  in
   let open Netlink in
   let s = Socket.alloc () in
   Socket.connect s Socket.NETLINK_ROUTE ;
@@ -119,9 +119,10 @@ let get_link_stats () =
       List.exists
         (fun s -> Astring.String.is_prefix ~affix:s name)
         !monitor_whitelist
+      || List.mem name managed_host_net_devs
     in
     let is_vlan name =
-      Astring.String.is_prefix ~affix:"eth" name && String.contains name '.'
+      List.mem name managed_host_net_devs && String.contains name '.'
     in
     List.map (fun link -> standardise_name (Link.get_name link)) links
     |> (* Only keep interfaces with prefixes on the whitelist, and exclude VLAN
@@ -226,7 +227,7 @@ let rec monitor dbg () =
         Network_server.Bridge.get_all_bonds dbg from_cache
       in
       let add_bonds bonds devs = List.map fst bonds @ devs in
-      let devs = get_link_stats () |> add_bonds bonds |> get_stats bonds in
+      let devs = get_link_stats dbg () |> add_bonds bonds |> get_stats bonds in
       ( if List.length bonds <> Hashtbl.length bonds_status then
           let dead_bonds =
             Hashtbl.fold
diff --git a/ocaml/networkd/bin/network_server.ml b/ocaml/networkd/bin/network_server.ml
index 59c76e319..2797d5767 100644
--- a/ocaml/networkd/bin/network_server.ml
+++ b/ocaml/networkd/bin/network_server.ml
@@ -35,18 +35,144 @@ let write_config () =
     try Network_config.write_config !config
     with Network_config.Write_error -> ()
 
+let get_index_from_ethx = Network_config.get_index_from_ethx
+
+let sort_based_on_ethx () =
+  Sysfs.list ()
+  |> List.filter_map (fun name ->
+         if Sysfs.is_physical name then
+           get_index_from_ethx name |> Option.map (fun i -> (name, i))
+         else
+           None
+     )
+
+let read_previous_inventory previous_inventory =
+  try
+    Xapi_stdext_unix.Unixext.file_lines_fold
+      (fun acc line ->
+        match Inventory.parse_inventory_entry line with
+        | Some ("MANAGEMENT_INTERFACE", iface) ->
+            info "get management interface from previous inventory: %s" iface ;
+            (Some iface, snd acc)
+        | Some ("MANAGEMENT_ADDRESS_TYPE", addr_type) ->
+            info "get management address type from previous inventory: %s"
+              addr_type ;
+            (fst acc, Some addr_type)
+        | _ ->
+            acc
+      )
+      (None, None) previous_inventory
+  with e ->
+    error "Failed to read previous inventory %s: %s" previous_inventory
+      (Printexc.to_string e) ;
+    (None, None)
+
+let update_inventory () =
+  let previous_inventory = "/var/tmp/.previousInventory" in
+  match read_previous_inventory previous_inventory with
+  | Some iface, Some addr_type ->
+      Network_config.write_manage_iface_to_inventory iface addr_type
+  | _ ->
+      error "Failed to find management interface or address type from %s"
+        previous_inventory
+
+let changed_interfaces_after_upgrade interface_order =
+  let previous_eth_devs =
+    List.filter_map
+      (fun (iface, _) ->
+        iface |> get_index_from_ethx |> Option.map (fun idx -> (iface, idx))
+      )
+      !config.interface_config
+  in
+  List.filter_map
+    (fun (name, pos) ->
+      List.find_opt (fun dev -> dev.position = pos) interface_order |> function
+      | Some dev ->
+          if dev.name <> name then Some (name, dev.name) else None
+      | None ->
+          error "Can't find previous interface %s in sorted interfaces" name ;
+          None
+    )
+    previous_eth_devs
+
+let sort last_order =
+  let do_sort last_order =
+    match Network_device_order.sort last_order with
+    | Ok r ->
+        r
+    | Error err ->
+        error "Failed to sort interface order [%s]"
+          (Network_device_order.string_of_error err) ;
+        (last_order, [])
+  in
+  match (Network_config.device_already_renamed, last_order) with
+  | true, None ->
+      (* The net dev renamed version, skip sort *)
+      (None, [])
+  | true, Some _ ->
+      (* Impossible *)
+      error "%s: device renamed but order is not None" __FUNCTION__ ;
+      raise
+        (Network_error (Internal_error "device renamed but order is not None"))
+  | false, None ->
+      (* Upgrade from net dev renamed version. The previous order is converted
+         and passed to initial rules. Just use [] here to sort. *)
+      let interface_order, _ = do_sort [] in
+      let changed_interfaces =
+        changed_interfaces_after_upgrade interface_order
+      in
+      update_inventory () ;
+      (Some interface_order, changed_interfaces)
+  | false, Some last_order ->
+      let interface_order, changed_interfaces = do_sort last_order in
+      (Some interface_order, changed_interfaces)
+
+let update_changes last_config changed_interfaces =
+  let update_name name =
+    let new_name =
+      List.assoc_opt name changed_interfaces |> Option.value ~default:name
+    in
+    if name <> new_name then
+      debug "Renaming %s to %s" name new_name ;
+    new_name
+  in
+  let update_port (port, port_conf) =
+    ( update_name port
+    , {port_conf with interfaces= List.map update_name port_conf.interfaces}
+    )
+  in
+  let bridge_config =
+    List.map
+      (fun (bridge, bridge_conf) ->
+        ( bridge
+        , {bridge_conf with ports= List.map update_port bridge_conf.ports}
+        )
+      )
+      last_config.bridge_config
+  in
+  let interface_config =
+    List.map
+      (fun (name, conf) -> (update_name name, conf))
+      last_config.interface_config
+  in
+  (bridge_config, interface_config)
+
 let read_config () =
   try
     config := Network_config.read_config () ;
-    debug "Read configuration from networkd.db file."
+    debug "Read configuration from networkd.db file." ;
+    let interface_order, changes = sort !config.interface_order in
+    let bridge_config, interface_config = update_changes !config changes in
+    config := {!config with bridge_config; interface_config; interface_order}
   with Network_config.Read_error -> (
     try
       (* No configuration file found. Try to get the initial network setup from
        * the first-boot data written by the host installer. *)
-      config := Network_config.read_management_conf () ;
+      let interface_order, _ = sort Network_config.initial_interface_order in
+      config := Network_config.read_management_conf interface_order ;
       debug "Read configuration from management.conf file."
     with Network_config.Read_error ->
-      debug "Could not interpret the configuration in management.conf"
+      error "Could not interpret the configuration in management.conf"
   )
 
 let on_shutdown signal =
@@ -63,13 +189,30 @@ let on_timer () = write_config ()
 
 let clear_state () =
   write_lock := true ;
-  config := Network_config.empty_config
+  (* Do not clear interface_order, it is only maintained by networkd *)
+  config :=
+    {Network_config.empty_config with interface_order= !config.interface_order}
 
 let sync_state () =
   write_lock := false ;
   write_config ()
 
-let reset_state () = config := Network_config.read_management_conf ()
+let reset_state () =
+  let reset_order =
+    match !config.interface_order with
+    | Some _ ->
+        (* Use empty config interface_order to sort to generate fresh-install
+           state for currently-installed hardware *)
+        sort Network_config.empty_config.interface_order |> fst
+    | None ->
+        ignore
+          (Forkhelpers.execute_command_get_output
+             "/etc/sysconfig/network-scripts/interface-rename.py"
+             ["--reset-to-install"]
+          ) ;
+        None
+  in
+  config := Network_config.read_management_conf reset_order
 
 let set_gateway_interface _dbg name =
   (* Remove dhclient conf (if any) for the old and new gateway interfaces.
@@ -269,6 +412,24 @@ module Interface = struct
   let get_all dbg () =
     Debug.with_thread_associated dbg (fun () -> Sysfs.list ()) ()
 
+  let get_interface_positions dbg () =
+    Debug.with_thread_associated dbg
+      (fun () ->
+        match !config.interface_order with
+        | Some order ->
+            List.filter_map
+              (fun dev ->
+                if dev.present then
+                  Some (dev.name, dev.position)
+                else
+                  None
+              )
+              order
+        | None ->
+            sort_based_on_ethx ()
+      )
+      ()
+
   let exists dbg name =
     Debug.with_thread_associated dbg
       (fun () -> List.mem name (Sysfs.list ()))
diff --git a/ocaml/networkd/bin/networkd.ml b/ocaml/networkd/bin/networkd.ml
index bd4b813f6..cfb712e09 100644
--- a/ocaml/networkd/bin/networkd.ml
+++ b/ocaml/networkd/bin/networkd.ml
@@ -183,6 +183,7 @@ let bind () =
   S.set_gateway_interface set_gateway_interface ;
   S.set_dns_interface set_dns_interface ;
   S.Interface.get_all Interface.get_all ;
+  S.Interface.get_interface_positions Interface.get_interface_positions ;
   S.Interface.exists Interface.exists ;
   S.Interface.get_mac Interface.get_mac ;
   S.Interface.get_pci_bus_path Interface.get_pci_bus_path ;
diff --git a/ocaml/networkd/bin_db/networkd_db.ml b/ocaml/networkd/bin_db/networkd_db.ml
index f62021828..f4a0f5074 100644
--- a/ocaml/networkd/bin_db/networkd_db.ml
+++ b/ocaml/networkd/bin_db/networkd_db.ml
@@ -16,6 +16,10 @@ open Network_interface
 
 let name = "networkd_db"
 
+type error = Skip | Msg of string
+
+let ( let* ) = Result.bind
+
 let _ =
   let bridge = ref "" in
   let iface = ref "" in
@@ -31,22 +35,59 @@ let _ =
     (Printf.sprintf "Usage: %s [-bridge <bridge> | -iface <interface>]" name) ;
   try
     let config = Network_config.read_config () in
-    if !bridge <> "" then
-      if List.mem_assoc !bridge config.bridge_config then (
-        let bridge_config = List.assoc !bridge config.bridge_config in
-        let ifaces =
-          List.concat_map (fun (_, port) -> port.interfaces) bridge_config.ports
+    let r =
+      let* bridge = if !bridge = "" then Error Skip else Ok !bridge in
+      let* bridge_config =
+        let error = Msg (Printf.sprintf "Could not find bridge %s\n" bridge) in
+        List.assoc_opt bridge config.bridge_config
+        |> Option.to_result ~none:error
+      in
+      let ifaces =
+        List.concat_map (fun (_, port) -> port.interfaces) bridge_config.ports
+      in
+      let* macs =
+        let to_mac ~order name =
+          match List.find_opt (fun dev -> dev.name = name) order with
+          | Some dev ->
+              Either.Left (Macaddr.to_string dev.mac)
+          | None ->
+              Either.Right name
         in
-        Printf.printf "interfaces=%s\n" (String.concat "," ifaces) ;
-        match bridge_config.vlan with
-        | None ->
-            ()
-        | Some (parent, id) ->
-            Printf.printf "vlan=%d\nparent=%s\n" id parent
-      ) else (
+        match (config.interface_order, ifaces) with
+        | Some order, _ :: _ ->
+            let oks, errs = List.partition_map (to_mac ~order) ifaces in
+            if errs = [] then
+              Ok oks
+            else
+              Error
+                (Msg
+                   (Printf.sprintf "Could not find MAC address(es) for %s"
+                      (String.concat ", " errs)
+                   )
+                )
+        | _, [] ->
+            (* No ifaces, no hwaddrs. *)
+            Ok []
+        | None, _ :: _ ->
+            (* Fallback to use the bridge MAC address when the interface_order
+               is not available. This can work only because the host installer
+               requires only one network interface to setup its own networking so far. *)
+            Ok (Option.to_list bridge_config.bridge_mac)
+      in
+      Printf.printf "interfaces=%s\n" (String.concat "," ifaces) ;
+      Printf.printf "hwaddrs=%s\n" (String.concat "," macs) ;
+      Option.iter
+        (fun (parent, id) -> Printf.printf "vlan=%d\nparent=%s\n" id parent)
+        bridge_config.vlan ;
+      Ok ()
+    in
+    ( match r with
+    | Ok () | Error Skip ->
+        ()
+    | Error (Msg msg) ->
         rc := 1 ;
-        Printf.fprintf stderr "Could not find bridge %s\n" !bridge
-      ) ;
+        Printf.fprintf stderr "%s" msg
+    ) ;
     if !iface <> "" then
       if List.mem_assoc !iface config.interface_config then
         let interface_config = List.assoc !iface config.interface_config in
diff --git a/ocaml/networkd/lib/dune b/ocaml/networkd/lib/dune
index 548d326a4..4a1dd03fb 100644
--- a/ocaml/networkd/lib/dune
+++ b/ocaml/networkd/lib/dune
@@ -4,6 +4,7 @@
  (libraries
   astring
   forkexec
+  macaddr
   mtime
   mtime.clock.os
   re
@@ -19,6 +20,7 @@
   xapi-stdext-threads
   xapi-stdext-unix
   xapi-inventory
+  xapi-idl
   xapi-idl.network
   xapi-log
   xapi-open-uri
diff --git a/ocaml/networkd/lib/network_config.ml b/ocaml/networkd/lib/network_config.ml
index 56eef61ce..d342e0ffb 100644
--- a/ocaml/networkd/lib/network_config.ml
+++ b/ocaml/networkd/lib/network_config.ml
@@ -22,17 +22,32 @@ exception Read_error
 
 exception Write_error
 
-let empty_config = default_config
+(* If the interface-rename script dir exists, the devices are already renamed
+   to eth<N>, the <N> indicates device order *)
+let device_already_renamed =
+  let dir = "/etc/sysconfig/network-scripts/interface-rename-data" in
+  Sys.file_exists dir && Sys.is_directory dir
+
+(* If devices have already been renamed, then interface_order is None,
+   since the order is now reflected in their names. *)
+let initial_interface_order = if device_already_renamed then None else Some []
+
+let empty_config =
+  {default_config with interface_order= initial_interface_order}
 
 let config_file_path = "/var/lib/xcp/networkd.db"
 
 let temp_vlan = "xentemp"
 
-let bridge_naming_convention (device : string) =
-  if Astring.String.is_prefix ~affix:"eth" device then
-    "xenbr" ^ String.sub device 3 (String.length device - 3)
-  else
-    "br" ^ device
+let get_index_from_ethx name =
+  try Scanf.sscanf name "eth%d%!" Option.some with _ -> None
+
+let bridge_naming_convention (device : string) pos_opt =
+  match pos_opt with
+  | Some index ->
+      "xenbr" ^ string_of_int index
+  | None ->
+      "br" ^ device
 
 let get_list_from ~sep ~key args =
   List.assoc_opt key args
@@ -79,7 +94,14 @@ let parse_dns_config args =
   let domains = get_list_from ~sep:" " ~key:"DOMAIN" args in
   (nameservers, domains)
 
-let read_management_conf () =
+let write_manage_iface_to_inventory bridge_name management_address_type =
+  info "Writing management interface to inventory: %s" bridge_name ;
+  Inventory.update Inventory._management_interface bridge_name ;
+  info "Writing management address type to inventory: %s"
+    management_address_type ;
+  Inventory.update Inventory._management_address_type management_address_type
+
+let read_management_conf interface_order =
   try
     let management_conf =
       Xapi_stdext_unix.Unixext.string_of_file
@@ -114,7 +136,31 @@ let read_management_conf () =
       | _, hd :: _ ->
           hd
     in
-    Inventory.reread_inventory () ;
+    let pos_opt =
+      match interface_order with
+      | Some order ->
+          List.find_map
+            (fun x -> if x.name = device then Some x.position else None)
+            order
+      | None ->
+          get_index_from_ethx device
+    in
+    let (ipv4_conf, ipv4_gateway), (ipv6_conf, ipv6_gateway) =
+      match (List.assoc_opt "MODE" args, List.assoc_opt "MODEV6" args) with
+      | None, None ->
+          error "%s: at least one of 'MODE', 'MODEV6' needs to be specified"
+            __FUNCTION__ ;
+          raise Read_error
+      | v4, v6 ->
+          (parse_ipv4_config args v4, parse_ipv6_config args v6)
+    in
+    let management_address_type =
+      (* Default to IPv4 unless we have only got an IPv6 admin interface *)
+      if ipv4_conf = None4 && ipv6_conf <> None6 then
+        "IPv6"
+      else
+        "IPv4"
+    in
     let bridge_name =
       let inventory_bridge =
         try Some (Inventory.lookup Inventory._management_interface)
@@ -124,7 +170,7 @@ let read_management_conf () =
       | Some "" | None ->
           let bridge =
             if vlan = None then
-              bridge_naming_convention device
+              bridge_naming_convention device pos_opt
             else
               (* At this point, we don't know what the VLAN bridge name will be,
                * so use a temporary name. Xapi will replace the bridge once the name
@@ -132,6 +178,8 @@ let read_management_conf () =
               temp_vlan
           in
           debug "No management bridge in inventory file... using %s" bridge ;
+          if not device_already_renamed then
+            write_manage_iface_to_inventory bridge management_address_type ;
           bridge
       | Some bridge ->
           debug "Management bridge in inventory file: %s" bridge ;
@@ -139,15 +187,6 @@ let read_management_conf () =
     in
     let mac = Network_utils.Ip.get_mac device in
     let dns = parse_dns_config args in
-    let (ipv4_conf, ipv4_gateway), (ipv6_conf, ipv6_gateway) =
-      match (List.assoc_opt "MODE" args, List.assoc_opt "MODEV6" args) with
-      | None, None ->
-          error "%s: at least one of 'MODE', 'MODEV6' needs to be specified"
-            __FUNCTION__ ;
-          raise Read_error
-      | v4, v6 ->
-          (parse_ipv4_config args v4, parse_ipv6_config args v6)
-    in
 
     let phy_interface = {default_interface with persistent_i= true} in
     let bridge_interface =
@@ -176,7 +215,7 @@ let read_management_conf () =
           , [(bridge_name, primary_bridge_conf)]
           )
       | Some vlan ->
-          let parent = bridge_naming_convention device in
+          let parent = bridge_naming_convention device pos_opt in
           let secondary_bridge_conf =
             {
               default_bridge with
@@ -203,6 +242,7 @@ let read_management_conf () =
     ; bridge_config
     ; gateway_interface= Some bridge_name
     ; dns_interface= Some bridge_name
+    ; interface_order
     }
   with e ->
     error "Error while trying to read firstboot data: %s\n%s"
diff --git a/ocaml/networkd/lib/network_device_order.ml b/ocaml/networkd/lib/network_device_order.ml
new file mode 100644
index 000000000..323163330
--- /dev/null
+++ b/ocaml/networkd/lib/network_device_order.ml
@@ -0,0 +1,570 @@
+(*
+ * Copyright (c) Cloud Software Group, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation; version 2.1 only. with the special
+ * exception on linking described in file LICENSE.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *)
+
+(** Generate an order for host network devices and keep the order as stable as possible.
+  *)
+
+module D = Debug.Make (struct let name = __MODULE__ end)
+
+open D
+open Network_interface
+
+let initial_rules_file_path =
+  "/etc/firstboot.d/data/initial_network_device_rules.conf"
+
+let ( let* ) = Result.bind
+
+let cmd_biosdevname = "/usr/sbin/biosdevname"
+
+type error =
+  | Pci_addr_parse_error of string
+  | Mac_addr_parse_error of string
+  | Rule_parse_error of string
+  | Missing_biosdevname_key of string
+  | Duplicate_mac_address
+  | Duplicate_position
+  | Invalid_biosdevname_key_value of (string * string)
+
+let string_of_error = function
+  | Pci_addr_parse_error s ->
+      Printf.sprintf "Invalid PCI address: %s" s
+  | Mac_addr_parse_error s ->
+      Printf.sprintf "Invalid MAC address: %s" s
+  | Rule_parse_error s ->
+      Printf.sprintf "Invalid rule: %s" s
+  | Missing_biosdevname_key k ->
+      Printf.sprintf "Missing key in biosdevname output: %s" k
+  | Duplicate_mac_address ->
+      "Duplicate MAC address"
+  | Duplicate_position ->
+      "Duplicate position"
+  | Invalid_biosdevname_key_value (k, v) ->
+      Printf.sprintf "Invalid key-value pair in biosdevname output: %s=%s" k v
+
+module Pciaddr = struct
+  type t = Xcp_pci.address
+
+  let default = Xcp_pci.{domain= 0; bus= 0; dev= 0; fn= 0}
+
+  let to_string = Xcp_pci.string_of_address
+
+  let of_string s =
+    try Ok (Xcp_pci.address_of_string s)
+    with _ -> Error (Pci_addr_parse_error s)
+
+  let compare t1 t2 =
+    let open Xcp_pci in
+    let ( <?> ) a b = if a = 0 then b else a in
+    compare t1.domain t2.domain
+    <?> compare t1.bus t2.bus
+    <?> compare t1.dev t2.dev
+    <?> compare t1.fn t2.fn
+end
+
+module Macaddr = struct
+  include Macaddr
+
+  let of_string s =
+    of_string s |> Result.map_error (fun _ -> Mac_addr_parse_error s)
+end
+
+module PciaddrMap = Map.Make (Pciaddr)
+module MacaddrSet = Set.Make (Macaddr)
+module MacaddrMap = Map.Make (Macaddr)
+module IntMap = Map.Make (Int)
+module IntSet = Set.Make (Int)
+
+module UniqueMap (M : Map.S) : sig
+  exception Duplicate_key
+
+  val of_unique_list : ('a -> M.key) -> 'a list -> 'a M.t
+  (** [of_unique_list map lst] creates a map with the values in [lst]. Their
+      keys are created by calling [map value]. Raises [Duplicate_key] whenever
+      more than one value in [lst] produces the same key when calling
+      [map value]. *)
+end = struct
+  exception Duplicate_key
+
+  let fail _ = raise Duplicate_key
+
+  let of_unique_list map l =
+    List.fold_left
+      (fun acc v ->
+        let f x = Some (Option.fold ~none:v ~some:fail x) in
+        M.update (map v) f acc
+      )
+      M.empty l
+end
+
+module MultiMap (M : Map.S) : sig
+  val of_list : ('a -> M.key) -> 'a list -> 'a list M.t
+  (** [of_list map lst] creates a map with the values in [lst]. Their keys are
+      created by calling [map value]. Whenever more than a value generates the
+      key when calling [map value], the values are concatenated as a list. *)
+end = struct
+  let of_list map l =
+    List.fold_left
+      (fun acc v ->
+        let f x = Some (Option.fold ~none:[v] ~some:(List.cons v) x) in
+        M.update (map v) f acc
+      )
+      M.empty l
+end
+
+module IntUniqueMap = UniqueMap (IntMap)
+module MacaddrUniqueMap = UniqueMap (MacaddrMap)
+module PciaddrMultiMap = MultiMap (PciaddrMap)
+
+let fold_results (l : ('a, 'e) result list) : ('a list, 'e) result =
+  List.fold_left
+    (fun acc r ->
+      match (acc, r) with
+      | Ok acc, Ok r ->
+          Ok (r :: acc)
+      | Error error, _ ->
+          Error error
+      | Ok _, Error error ->
+          Error error
+    )
+    (Ok []) l
+
+module Rule = struct
+  type index = Mac_addr of Macaddr.t | Pci_addr of Pciaddr.t | Label of string
+
+  type t = {position: int; index: index}
+
+  let matches ~(mac : Macaddr.t) ~(pci : Pciaddr.t) ~(label : string) t : bool =
+    match t.index with
+    | Mac_addr mac' ->
+        mac' = mac
+    | Pci_addr pci' ->
+        pci' = pci
+    | Label label' ->
+        label' = label
+
+  let parse line =
+    debug "%s: line: %s" __FUNCTION__ line ;
+    try
+      Scanf.sscanf line {|%d:%s@="%s@"|} (fun position ty value ->
+          let to_rule index = Ok {position; index} in
+          match ty with
+          | "pci" ->
+              let* pci = Pciaddr.of_string value in
+              to_rule (Pci_addr pci)
+          | "mac" ->
+              let* mac = Macaddr.of_string value in
+              to_rule (Mac_addr mac)
+          | "label" ->
+              to_rule (Label value)
+          | _ ->
+              Error (Rule_parse_error line)
+      )
+    with _ -> Error (Rule_parse_error line)
+
+  let validate (l : (t, error) result list) =
+    let* rules = fold_results l in
+    try
+      IntUniqueMap.of_unique_list (fun dev -> dev.position) rules |> ignore ;
+      Ok rules
+    with IntUniqueMap.Duplicate_key -> Error Duplicate_position
+
+  let read ~(path : string) : (t list, error) result =
+    if not (Sys.file_exists path) then
+      Ok []
+    else
+      Xapi_stdext_unix.Unixext.read_lines ~path |> List.map parse |> validate
+end
+
+module Dev = struct
+  type t = {
+      name: Network_interface.iface
+    ; mac: Network_interface.mac_address
+    ; pci: Xcp_pci.address
+    ; bios_eth_order: int
+    ; multi_nic: bool
+  }
+
+  let default =
+    {
+      name= ""
+    ; mac= Macaddr.of_string_exn "00:00:00:00:00:00"
+    ; pci= Pciaddr.default
+    ; bios_eth_order= -1
+    ; multi_nic= false
+    }
+
+  let compare_on_mac t1 t2 = Macaddr.compare t1.mac t2.mac
+
+  let compare_on_bios_eth_order t1 t2 =
+    compare t1.bios_eth_order t2.bios_eth_order
+
+  let to_string t =
+    Printf.sprintf "Name=%s; MAC=%s; PCI=%s; bios_eth_order=%d; multi_nic=%s"
+      t.name (Macaddr.to_string t.mac) (Pciaddr.to_string t.pci)
+      t.bios_eth_order
+      (string_of_bool t.multi_nic)
+
+  let n_of_ethn ethn =
+    try Ok (Scanf.sscanf ethn "eth%d" (fun n -> n))
+    with _ -> Error (Invalid_biosdevname_key_value ("BIOS device", ethn))
+
+  let parse output_of_one_dev =
+    debug "%s: line: %s" __FUNCTION__ output_of_one_dev ;
+    let kvs =
+      let open Astring.String in
+      cuts ~sep:"\n" output_of_one_dev
+      |> List.filter_map (fun line ->
+             cut ~sep:":" line |> Option.map (fun (k, v) -> (trim k, trim v))
+         )
+    in
+    List.iter (fun (k, v) -> debug "%s: [%s]=[%s]" __FUNCTION__ k v) kvs ;
+    [
+      ( "BIOS device"
+      , fun r v ->
+          let* bios_eth_order = n_of_ethn v in
+          Ok {r with bios_eth_order}
+      )
+    ; ("Kernel name", fun r v -> Ok {r with name= v})
+    ; ( "Assigned MAC"
+      , fun r v ->
+          let* mac = Macaddr.of_string v in
+          Ok {r with mac}
+      )
+    ; ( "Bus Info"
+      , fun r v ->
+          let pci_str =
+            match String.split_on_char '-' v with
+            | ["usb"; pci; _] ->
+                (* For USB device, the bus-info is like
+                   "usb-<PCI address of USB controller>-<USB port path>",
+                    use the PCI address of the USB controller *)
+                pci
+            | _ ->
+                v
+          in
+          let* pci = Pciaddr.of_string pci_str in
+          Ok {r with pci}
+      )
+    ]
+    |> List.fold_left
+         (fun acc (k, f) ->
+           let* r = acc in
+           match List.assoc_opt k kvs with
+           | Some v ->
+               Result.map_error
+                 (fun _ -> Invalid_biosdevname_key_value (k, v))
+                 (f r v)
+           | None ->
+               Error (Missing_biosdevname_key k)
+         )
+         (Ok default)
+
+  let update_multi_nic devs =
+    let pci_cnt =
+      let f o = Some (Option.fold ~none:1 ~some:(fun c -> c + 1) o) in
+      List.fold_left
+        (fun acc dev -> PciaddrMap.update dev.pci f acc)
+        PciaddrMap.empty devs
+    in
+    List.map
+      (fun dev : t ->
+        let multi_nic =
+          (* Will never raise exception or be < 1 *)
+          let c = PciaddrMap.find dev.pci pci_cnt in
+          if c > 1 then true else false
+        in
+        {dev with multi_nic}
+      )
+      devs
+
+  let not_ibft t =
+    try Scanf.sscanf t.name "ibft%d%!" (fun _ -> false) with _ -> true
+
+  let get_all () : (t list, error) result =
+    let* devs =
+      Network_utils.call_script cmd_biosdevname
+        ["--policy"; "all_ethN"; "-d"; "-x"]
+      |> Astring.String.cuts ~sep:"\n\n"
+      |> List.filter (fun line -> line <> "")
+      |> List.map parse
+      |> fold_results
+    in
+    let devs = List.filter not_ibft devs in
+    try
+      MacaddrUniqueMap.of_unique_list (fun v -> v.mac) devs |> ignore ;
+      Ok (update_multi_nic devs)
+    with MacaddrUniqueMap.Duplicate_key -> Error Duplicate_mac_address
+end
+
+module OrderedDev = struct
+  type t = Network_interface.ordered_iface
+
+  let compare_on_mac t1 t2 = Macaddr.compare t1.mac t2.mac
+
+  let to_string t =
+    Printf.sprintf "position=%d; name=%s; MAC=%s; PCI=%s; present=%s" t.position
+      t.name (Macaddr.to_string t.mac) (Pciaddr.to_string t.pci)
+      (string_of_bool t.present)
+
+  let map_by_pci (l : t list) : t list PciaddrMap.t =
+    PciaddrMultiMap.of_list (fun v -> v.pci) l
+
+  let map_by_position (l : t list) : (t IntMap.t, error) result =
+    try Ok (IntUniqueMap.of_unique_list (fun v -> v.position) l)
+    with _ -> Error Duplicate_position
+
+  let validate_no_duplicate_position (l : t list) : (t list, error) result =
+    try
+      IntUniqueMap.of_unique_list (fun dev -> dev.position) l |> ignore ;
+      Ok l
+    with _ -> Error Duplicate_position
+
+  let validate_no_duplicate_mac (l : t list) : (t list, error) result =
+    try
+      MacaddrUniqueMap.of_unique_list (fun dev -> dev.mac) l |> ignore ;
+      Ok l
+    with _ -> Error Duplicate_mac_address
+
+  let validate_order (l : t list) : (t list, error) result =
+    let* l = validate_no_duplicate_position l in
+    validate_no_duplicate_mac l
+
+  let assign_position (dev : Dev.t) position =
+    Network_interface.
+      {name= dev.name; mac= dev.mac; pci= dev.pci; position; present= true}
+end
+
+type ordering = OrderedDev.t list * Dev.t list
+
+let assign_position_by_rules ~(rules : Rule.t list)
+    ((ordered, unordered) : ordering) : ordering =
+  List.fold_left
+    (fun (acc_ordered, acc_unordered) (dev : Dev.t) ->
+      match
+        List.find_opt
+          (Rule.matches ~mac:dev.mac ~pci:dev.pci ~label:dev.name)
+          rules
+      with
+      | Some {position; _} ->
+          debug "%s: assign position: %d <- %s" __FUNCTION__ position
+            (Dev.to_string dev) ;
+          let dev' = OrderedDev.assign_position dev position in
+          (dev' :: acc_ordered, acc_unordered)
+      | None ->
+          (acc_ordered, dev :: acc_unordered)
+    )
+    (ordered, []) unordered
+
+let assign_position_by_mac ~(last_order : OrderedDev.t list)
+    ((ordered, unordered) : ordering) : ordering =
+  List.fold_left
+    (fun (acc_ordered, acc_unordered) (dev : Dev.t) ->
+      match List.find_opt (fun dev' -> dev.mac = dev'.mac) last_order with
+      | Some {position; _} ->
+          (* Found a MAC matched network device in [last_order]: assign the position as last. *)
+          debug "%s: assign position: %d <- %s" __FUNCTION__ position
+            (Dev.to_string dev) ;
+          let dev' = OrderedDev.assign_position dev position in
+          (dev' :: acc_ordered, acc_unordered)
+      | None ->
+          debug "%s: skip %s" __FUNCTION__ (Dev.to_string dev) ;
+          (* a new network device: leave it unassigned at the moment *)
+          (acc_ordered, dev :: acc_unordered)
+    )
+    (ordered, []) unordered
+
+let assign_position_by_pci ~(last_pcis : OrderedDev.t list PciaddrMap.t)
+    ~(curr_macs : MacaddrSet.t) ((ordered, unordered) : ordering) : ordering =
+  List.fold_left
+    (fun (acc_ordered, acc_unordered) (dev : Dev.t) ->
+      match (dev, PciaddrMap.find_opt dev.pci last_pcis) with
+      | Dev.{multi_nic= false; _}, Some [{position; mac; _}] -> (
+        (* Not a multi-nic function.
+           And found a ever-seen device which had located at the same PCI address. *)
+        match MacaddrSet.find_opt mac curr_macs with
+        | None ->
+            (* The ever-seen device has been removed - not in current MAC addresses.
+               This is a replacement: assign the position as before. *)
+            debug "%s: assign position: %d <- %s" __FUNCTION__ position
+              (Dev.to_string dev) ;
+            let dev' = OrderedDev.assign_position dev position in
+            (dev' :: acc_ordered, acc_unordered)
+        | Some _ ->
+            (* The ever-seen device is still presenting this time.
+               It must have been positioned via the MAC address already. But its PCI address changes. *)
+            debug "%s: skip (seen) %s" __FUNCTION__ (Dev.to_string dev) ;
+            (acc_ordered, dev :: acc_unordered)
+      )
+      | _ ->
+          debug "%s: skip %s" __FUNCTION__ (Dev.to_string dev) ;
+          (acc_ordered, dev :: acc_unordered)
+    )
+    (ordered, []) unordered
+
+let assign_position_for_multinic ~(last_pcis : OrderedDev.t list PciaddrMap.t)
+    ~(assigned_positions : IntSet.t) (multinics : Dev.t list) : ordering =
+  PciaddrMap.fold
+    (fun pci devs (acc_ordered, acc_unordered) ->
+      (* The [last_devs] are the devices which were previously occupying the PCI address.
+         The positions of these devices are called the "last positions". *)
+      let last_devs =
+        PciaddrMap.find_opt pci last_pcis |> Option.value ~default:[]
+      in
+      match
+        ( List.exists
+            (fun {position; _} -> IntSet.mem position assigned_positions)
+            last_devs
+        , List.length devs = List.length last_devs
+        )
+      with
+      | false, true ->
+          (* All the "last positions" have not been assigned yet.
+             And no change on the number of devices sharing the PCI address.
+             Re-assign the "last positions" by sorting with MAC addresses. *)
+          let devs' = List.sort Dev.compare_on_mac devs in
+          let lasts' = List.sort OrderedDev.compare_on_mac last_devs in
+          let ordered_devs =
+            List.rev_map2
+              (fun dev last ->
+                let position = last.position in
+                debug "%s: assign position: %d <- %s" __FUNCTION__ position
+                  (Dev.to_string dev) ;
+                OrderedDev.assign_position dev position
+              )
+              devs' lasts'
+          in
+          (List.rev_append ordered_devs acc_ordered, acc_unordered)
+      | true, _
+      (* Some of the "last positions" have been assigned by MAC address.
+         But there are some new ones reported this time. *)
+      | false, false ->
+          (* This means at this PCI address, the devices have completely
+             different MAC addresses and the number of devices changes as well.
+             Consider them being new devices. *)
+
+          (* Collect all BIOS eth order numbers *)
+          let bios_eth_orders =
+            devs
+            |> List.map (fun dev -> dev.Dev.bios_eth_order)
+            |> List.sort compare
+          in
+          (* Re-assgin the BIOS eth order by zipping the BIOS eth order and MAC order. *)
+          let unordered_devs =
+            devs
+            |> List.stable_sort Dev.compare_on_mac
+            |> List.rev_map2
+                 (fun bios_eth_order dev -> Dev.{dev with bios_eth_order})
+                 bios_eth_orders
+          in
+          (acc_ordered, List.rev_append unordered_devs acc_unordered)
+    )
+    (PciaddrMultiMap.of_list (fun v -> v.Dev.pci) multinics)
+    ([], [])
+
+let assign_position_for_remaining ~(max_position : int) (devs : Dev.t list) :
+    OrderedDev.t list =
+  List.fold_left
+    (fun (acc_pos, acc) (dev : Dev.t) ->
+      let pos = acc_pos + 1 in
+      debug "%s: assign position: %d <- %s" __FUNCTION__ pos (Dev.to_string dev) ;
+      let dev' = OrderedDev.assign_position dev pos in
+      (pos, dev' :: acc)
+    )
+    (max_position, []) devs
+  |> snd
+
+let sort' ~(currents : Dev.t list) ~(rules : Rule.t list)
+    ~(last_order : OrderedDev.t list) : (OrderedDev.t list, error) result =
+  let open Dev in
+  let curr_macs =
+    currents |> List.map (fun dev -> dev.mac) |> MacaddrSet.of_list
+  in
+  let last_pcis = OrderedDev.map_by_pci last_order in
+  let ordered, unordered =
+    ([], currents)
+    |> assign_position_by_rules ~rules
+    |> assign_position_by_mac ~last_order
+    |> assign_position_by_pci ~last_pcis ~curr_macs
+  in
+  let ordered, remaining =
+    (* Split the unordered list into two:
+         multinics - the devices each share a PCI BUS ID with others (multinic function).
+         remaining - the deivces each occupy a PCI BUS ID exclusively. *)
+    let multinics, remaining =
+      unordered |> List.partition (fun dev -> dev.multi_nic)
+    in
+    let assigned_positions =
+      ordered |> List.map (fun dev -> dev.position) |> IntSet.of_list
+    in
+    let ordered', unordered' =
+      assign_position_for_multinic ~last_pcis ~assigned_positions multinics
+    in
+    (List.rev_append ordered ordered', List.rev_append remaining unordered')
+  in
+  let* m = OrderedDev.map_by_position ordered in
+  let removed =
+    last_order
+    |> List.filter_map (fun (dev : OrderedDev.t) ->
+           if MacaddrSet.mem dev.mac curr_macs then
+             None
+           else
+             Some {dev with present= false}
+       )
+    |> List.filter (fun dev -> not (IntMap.mem dev.position m))
+  in
+  let ordered = List.rev_append ordered removed in
+  let max_position =
+    List.fold_left
+      (fun max dev -> if max < dev.position then dev.position else max)
+      (-1) ordered
+  in
+  let new_order =
+    remaining
+    |> List.stable_sort compare_on_bios_eth_order
+    |> assign_position_for_remaining ~max_position
+    |> List.rev_append ordered
+  in
+  OrderedDev.validate_order new_order
+
+let sort last_order =
+  let* rules = Rule.read ~path:initial_rules_file_path in
+  let rules, last_order =
+    if last_order = [] then
+      (rules, [])
+    else
+      ([], last_order)
+  in
+  let* currents = Dev.get_all () in
+  currents
+  |> List.iter (fun x -> debug "%s current: %s" __FUNCTION__ (Dev.to_string x)) ;
+  let* new_order = sort' ~currents ~rules ~last_order in
+  new_order
+  |> List.iter (fun x ->
+         debug "%s new order: %s" __FUNCTION__ (OrderedDev.to_string x)
+     ) ;
+
+  (* Find the NICs whose name changes *)
+  let* m = OrderedDev.map_by_position last_order in
+  let changes =
+    List.fold_left
+      (fun acc {position; name= curr; _} ->
+        match IntMap.find_opt position m with
+        | Some {name= last; _} when last <> curr ->
+            (last, curr) :: acc
+        | _ ->
+            acc
+      )
+      [] new_order
+  in
+  Ok (new_order, changes)
diff --git a/ocaml/networkd/lib/network_device_order.mli b/ocaml/networkd/lib/network_device_order.mli
new file mode 100644
index 000000000..8bd83a13e
--- /dev/null
+++ b/ocaml/networkd/lib/network_device_order.mli
@@ -0,0 +1,143 @@
+(*
+ * Copyright (c) Cloud Software Group, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation; version 2.1 only. with the special
+ * exception on linking described in file LICENSE.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *)
+
+(** Generate an order for host network devices and keep the order as stable as
+    possible. *)
+
+type error =
+  | Pci_addr_parse_error of string
+  | Mac_addr_parse_error of string
+  | Rule_parse_error of string
+  | Missing_biosdevname_key of string
+  | Duplicate_mac_address
+  | Duplicate_position
+  | Invalid_biosdevname_key_value of (string * string)
+
+val string_of_error : error -> string
+(** [string_of_error e] returns a string representation of the error [e]. *)
+
+(** PCI address in format SBDF: domain:bus:device:function *)
+module Pciaddr : sig
+  (** Type of the PCI address *)
+  type t = Xcp_pci.address
+
+  val of_string : string -> (t, error) result
+  (** [of_string s] returns [Ok pci] where [pci] is the PCI address converted
+      from [s]. Otherwise, it returns [Error error] whenever [s] can't be
+      parsed. [error] is for the parsing failure. *)
+
+  val compare : t -> t -> int
+  (** [compare x y] return 0 if [x] is equal to [y]; a negative integer if [x]
+      is less than [y], and a positive integer if [x] is greater than [y]. *)
+end
+
+module Macaddr : sig
+  type t = Macaddr.t
+
+  val of_string : string -> (t, error) result
+  (** [of_string s] returns [Ok pci] where [pci] is the PCI address converted
+      from [s]. Otherwise, it returns [Error error] whenever [s] can't be
+      parsed. [error] is for the parsing failure. *)
+end
+
+(** A rule specifies a position for a network device which can be identified by
+    MAC address, PCI address, or name label. *)
+module Rule : sig
+  type index =
+    | Mac_addr of Macaddr.t
+    | Pci_addr of Pciaddr.t
+    | Label of string  (** Type of mapping *)
+
+  (** Type of one mapping configuration. *)
+  type t = {position: int; index: index}
+
+  val read : path:string -> (t list, error) result
+  (** [read ~path] returns either [Ok rules], where [rules] are parsed from the
+      content of the file at [path], or [Error error], where [error] is the
+      reason for the parsing failure. The file at [path] contains lines in the
+      following format:
+        <N>:<label|mac|pci>="<value>", where
+        label: means the <value> is the name label of the device,
+        mac: means the <value> is the MAC address of the device like
+             00:02:C9:ED:FD:F0,
+        pci: means the <value> is the PCI address (in SBDF format) of the device
+             locates at, like 0000:05:00.0. *)
+
+  val matches : mac:Macaddr.t -> pci:Pciaddr.t -> label:string -> t -> bool
+  (** [true] if any of the [mac], [pci], or [label] meets the rule [t]. *)
+end
+
+(** A network device recognized by biosdevname *)
+module Dev : sig
+  (** Type of an network deivce parsed from the output of biosdevname. *)
+  type t = {
+      name: Network_interface.iface
+    ; mac: Network_interface.mac_address
+    ; pci: Xcp_pci.address
+    ; bios_eth_order: int
+          (** The <N> in eth<N> which is the value of "BIOS device" from output
+              of [biosdevname --policy all_ethN], is greater than or equal to 0.
+            *)
+    ; multi_nic: bool
+          (** [true] if there are other devices locate at the same PCI address.
+              Otherwise [false]. *)
+  }
+
+  val get_all : unit -> (t list, error) result
+  (** [get_all ()] returns [Ok l], where l is a list of network devices parsed
+      from the output of biosdevname. Otherwise, it returns [Error error], where
+      [error] is the reason for the parsing failure. *)
+end
+
+module IntMap : Map.S with type key = int
+
+(** A network device which has been assigned a postion in the order  by sorting *)
+module OrderedDev : sig
+  (** Type of an ordered network device. *)
+  type t = Network_interface.ordered_iface
+
+  val map_by_position : t list -> (t IntMap.t, error) result
+  (** [map_by_position lst] returns [Ok map], where [map] is a map with values
+      from [lst] and their keys are positions. It returns
+      [Error Duplicate_position] if more than one value in [lst] has the same
+      position. *)
+
+  val validate_order : t list -> (t list, error) result
+  (** [validate_order devs] returns [Ok lst], where [lst] is a list of devices
+      without duplicate MAC addresses or duplicate positions. Otherwise,
+      [Error error] is returned, where [error] is either Duplicate_position or
+      Duplicate_mac_address. *)
+
+  val assign_position : Dev.t -> int -> Network_interface.ordered_iface
+  (** [assign_position dev pos] returns a device with [pos] assigned. *)
+end
+
+val sort :
+     OrderedDev.t list
+  -> (OrderedDev.t list * (string * string) list, error) result
+(** [sort last_order] sorts and generates an order based on [last_order]. It
+    returns [Ok (order, changes)], where [order] is a list of devices each
+    assigned unique positions, and [changes] is a list of pairs like
+    [(old, new)]. In these pairs, [old] is the name of the device from the
+    previous call to [sort], and [new] is the current name of the device.
+    It returns [Error error] when it fails to generate an order.[error] is the
+    reason for the failure. *)
+
+(* Below is exposed only for unit tests *)
+
+val sort' :
+     currents:Dev.t list
+  -> rules:Rule.t list
+  -> last_order:OrderedDev.t list
+  -> (OrderedDev.t list, error) result
diff --git a/ocaml/networkd/test/dune b/ocaml/networkd/test/dune
index b3519ce2e..0141d108c 100644
--- a/ocaml/networkd/test/dune
+++ b/ocaml/networkd/test/dune
@@ -6,9 +6,12 @@
   astring
   
   fmt
+  macaddr
   networklibs
   rpclib.core
   rpclib.json
+  xapi-idl
+  xapi-idl.network
   xapi-log
   xapi-test-utils)
 )
diff --git a/ocaml/networkd/test/network_test.ml b/ocaml/networkd/test/network_test.ml
index 601fe8055..e3c8029c7 100644
--- a/ocaml/networkd/test/network_test.ml
+++ b/ocaml/networkd/test/network_test.ml
@@ -15,4 +15,8 @@
 let () =
   Debug.log_to_stdout () ;
   Alcotest.run "base_suite"
-    (Network_test_lacp_properties.suite @ Test_jsonrpc_client.tests)
+    (Network_test_lacp_properties.suite
+    @ Test_jsonrpc_client.tests
+    @ Test_network_device_order_inherited.tests
+    @ Test_network_device_order.tests
+    )
diff --git a/ocaml/networkd/test/test_network_device_order.ml b/ocaml/networkd/test/test_network_device_order.ml
new file mode 100644
index 000000000..b3fd21b89
--- /dev/null
+++ b/ocaml/networkd/test/test_network_device_order.ml
@@ -0,0 +1,478 @@
+(*
+ * Copyright (c) Cloud Software Group, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation; version 2.1 only. with the special
+ * exception on linking described in file LICENSE.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *)
+
+open Network_device_order
+open Network_interface
+
+let pci_addr0 = Pciaddr.of_string "0000:01:0f.0" |> Result.get_ok
+
+let pci_addr1 = Pciaddr.of_string "0000:01:0f.1" |> Result.get_ok
+
+let pci_addr2 = Pciaddr.of_string "0000:01:0f.2" |> Result.get_ok
+
+let pci_addr3 = Pciaddr.of_string "0000:01:0f.3" |> Result.get_ok
+
+let pci_addr4 = Pciaddr.of_string "0000:05:0f.0" |> Result.get_ok
+
+let mac_addr0 = Macaddr.of_string "ec:f4:bb:e6:d7:b8" |> Result.get_ok
+
+let mac_addr1 = Macaddr.of_string "ec:f4:bb:e6:d7:b9" |> Result.get_ok
+
+let mac_addr2 = Macaddr.of_string "ec:f4:bb:e6:d7:ba" |> Result.get_ok
+
+let mac_addr3 = Macaddr.of_string "ec:f4:bb:e6:d7:bb" |> Result.get_ok
+
+let mac_addr4 = Macaddr.of_string "00:02:c9:ed:fd:f0" |> Result.get_ok
+
+let mac_addr5 = Macaddr.of_string "00:02:c9:ed:fd:f1" |> Result.get_ok
+
+let name0 = "eno1"
+
+let name1 = "eno2"
+
+let name2 = "eno3"
+
+let name3 = "eno4"
+
+let name4 = "enp5s0"
+
+let name5 = "enp5s0d1"
+
+let seen_dev0 =
+  {name= name0; pci= pci_addr0; mac= mac_addr0; position= 0; present= true}
+
+let seen_dev1 =
+  {name= name1; pci= pci_addr1; mac= mac_addr1; position= 1; present= true}
+
+let seen_dev2 =
+  {name= name2; pci= pci_addr2; mac= mac_addr2; position= 2; present= true}
+
+let seen_dev3 =
+  {name= name3; pci= pci_addr3; mac= mac_addr3; position= 3; present= true}
+
+let seen_dev4 =
+  {name= name4; pci= pci_addr4; mac= mac_addr4; position= 4; present= true}
+
+let seen_dev5 =
+  {name= name5; pci= pci_addr4; mac= mac_addr5; position= 5; present= true}
+
+let dev0 =
+  {
+    Dev.name= name0
+  ; pci= pci_addr0
+  ; mac= mac_addr0
+  ; bios_eth_order= 0
+  ; multi_nic= false
+  }
+
+let dev1 =
+  {
+    Dev.name= name1
+  ; pci= pci_addr1
+  ; mac= mac_addr1
+  ; bios_eth_order= 1
+  ; multi_nic= false
+  }
+
+let dev2 =
+  {
+    Dev.name= name2
+  ; pci= pci_addr2
+  ; mac= mac_addr2
+  ; bios_eth_order= 2
+  ; multi_nic= false
+  }
+
+let dev3 =
+  {
+    Dev.name= name3
+  ; pci= pci_addr3
+  ; mac= mac_addr3
+  ; bios_eth_order= 3
+  ; multi_nic= false
+  }
+
+let dev4 =
+  {
+    Dev.name= name4
+  ; pci= pci_addr4
+  ; mac= mac_addr4
+  ; bios_eth_order= 4
+  ; multi_nic= true (* multinic: share PCI address with dev4 *)
+  }
+
+let dev5 =
+  {
+    Dev.name= name5
+  ; pci= pci_addr4
+  ; mac= mac_addr5
+  ; bios_eth_order= 5
+  ; multi_nic= true (* multinic: share PCI address with dev4 *)
+  }
+
+let plug dev devices = List.cons dev devices
+
+let unplug d devices = List.filter (fun dev -> dev.Dev.mac <> d.Dev.mac) devices
+
+let pos_of_mac mac order =
+  match List.find_opt (fun dev -> dev.mac = mac) order with
+  | Some {position; _} ->
+      position
+  | _ ->
+      -1
+
+let present_of_mac mac order =
+  match List.find_opt (fun dev -> dev.mac = mac) order with
+  | Some {present; _} ->
+      present
+  | _ ->
+      failwith "Can't find the device!"
+
+let test_postion_and_present expected_position expected_present dev order =
+  let mac = dev.Dev.mac in
+  let name = Format.asprintf "Position assigned for %a" Macaddr.pp mac in
+  Alcotest.(check int) name expected_position (pos_of_mac mac order) ;
+  Alcotest.(check bool) name expected_present (present_of_mac mac order)
+
+let test_default () =
+  let currents = [dev0; dev1; dev2; dev3; dev4; dev5] in
+  let order = sort' ~currents ~rules:[] ~last_order:[] in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "6 devices in the order" 6 (List.length order) ;
+  test_postion_and_present 0 true dev0 order ;
+  test_postion_and_present 1 true dev1 order ;
+  test_postion_and_present 2 true dev2 order ;
+  test_postion_and_present 3 true dev3 order ;
+  (* The dev4 and dev5 are multinic functions. To assign initial positions,
+     they are sorted by MAC addresses. *)
+  test_postion_and_present 4 true dev4 order ;
+  test_postion_and_present 5 true dev5 order
+
+let test_unstable_bios_eth_order () =
+  let dev4 = {dev4 with mac= mac_addr5; bios_eth_order= 9} in
+  let dev5 = {dev5 with mac= mac_addr4; bios_eth_order= 10} in
+  let currents = [dev0; dev1; dev2; dev3; dev4; dev5] in
+  let order = sort' ~currents ~rules:[] ~last_order:[] in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "6 devices in the order" 6 (List.length order) ;
+  test_postion_and_present 0 true dev0 order ;
+  test_postion_and_present 1 true dev1 order ;
+  test_postion_and_present 2 true dev2 order ;
+  test_postion_and_present 3 true dev3 order ;
+  (* The dev4 and dev5 are multinic functions. To assign initial positions,
+     they are sorted by MAC addresses. *)
+  test_postion_and_present 5 true dev4 order ;
+  test_postion_and_present 4 true dev5 order
+
+let test_initial_rules_via_mac () =
+  let currents = [dev0; dev1; dev2; dev3; dev4; dev5] in
+  let rules =
+    Rule.
+      [
+        {position= 0; index= Mac_addr mac_addr5}
+      ; {position= 1; index= Mac_addr mac_addr4}
+      ; {position= 2; index= Mac_addr mac_addr3}
+      ; {position= 3; index= Mac_addr mac_addr2}
+      ; {position= 4; index= Mac_addr mac_addr1}
+      ; {position= 5; index= Mac_addr mac_addr0}
+      ]
+  in
+  let order = sort' ~currents ~rules ~last_order:[] in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "6 devices in the order" 6 (List.length order) ;
+  test_postion_and_present 5 true dev0 order ;
+  test_postion_and_present 4 true dev1 order ;
+  test_postion_and_present 3 true dev2 order ;
+  test_postion_and_present 2 true dev3 order ;
+  test_postion_and_present 1 true dev4 order ;
+  test_postion_and_present 0 true dev5 order
+
+let test_initial_rules_via_label () =
+  let currents = [dev0; dev1; dev2; dev3; dev4; dev5] in
+  let rules =
+    Rule.
+      [
+        {position= 0; index= Label name5}
+      ; {position= 1; index= Label name4}
+      ; {position= 2; index= Label name3}
+      ; {position= 3; index= Label name2}
+      ; {position= 4; index= Label name1}
+      ; {position= 5; index= Label name0}
+      ]
+  in
+  let order = sort' ~currents ~rules ~last_order:[] in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "6 devices in the order" 6 (List.length order) ;
+  test_postion_and_present 5 true dev0 order ;
+  test_postion_and_present 4 true dev1 order ;
+  test_postion_and_present 3 true dev2 order ;
+  test_postion_and_present 2 true dev3 order ;
+  test_postion_and_present 1 true dev4 order ;
+  test_postion_and_present 0 true dev5 order
+
+let test_replacement () =
+  let mac_addr0' = Macaddr.of_string "fc:f4:bb:e6:d7:b8" |> Result.get_ok in
+  let mac_addr1' = Macaddr.of_string "fc:f4:bb:e6:d7:b9" |> Result.get_ok in
+  let dev0' =
+    {
+      Dev.name= "eno10"
+    ; pci= pci_addr0
+    ; mac= mac_addr0'
+    ; bios_eth_order=
+        1 (* this order is not expected to take effect in this case *)
+    ; multi_nic= false
+    }
+  in
+  let dev1' =
+    {
+      Dev.name= "eno11"
+    ; pci= pci_addr1
+    ; mac= mac_addr1'
+    ; bios_eth_order=
+        0 (* this order is not expected to take effect in this case *)
+    ; multi_nic= false
+    }
+  in
+  let last_order =
+    [seen_dev0; seen_dev1; seen_dev2; seen_dev3; seen_dev4; seen_dev5]
+  in
+  let currents =
+    [dev0; dev1; dev2; dev3; dev4; dev5]
+    |> unplug dev0
+    |> plug dev0'
+    |> unplug dev1
+    |> plug dev1'
+  in
+  let order = sort' ~currents ~rules:[] ~last_order in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+
+  Alcotest.(check int) "6 devices in the order" 6 (List.length order) ;
+
+  test_postion_and_present 0 true dev0' order ;
+  test_postion_and_present 1 true dev1' order ;
+  test_postion_and_present 2 true dev2 order ;
+  test_postion_and_present 3 true dev3 order ;
+  test_postion_and_present 4 true dev4 order ;
+  test_postion_and_present 5 true dev5 order
+
+let test_adding () =
+  let pci_addr6 = Pciaddr.of_string "0000:06:0f.0" |> Result.get_ok in
+  let mac_addr6 = Macaddr.of_string "fc:f4:bb:e6:d7:b8" |> Result.get_ok in
+  let pci_addr7 = Pciaddr.of_string "0000:06:0f.1" |> Result.get_ok in
+  let mac_addr7 = Macaddr.of_string "fc:f4:bb:e6:d7:b9" |> Result.get_ok in
+  let dev6 =
+    {
+      Dev.name= "eno6"
+    ; pci= pci_addr6
+    ; mac= mac_addr6
+    ; bios_eth_order= 1 (* This impacts the initial position *)
+    ; multi_nic= false
+    }
+  in
+  let dev7 =
+    {
+      Dev.name= "eno7"
+    ; pci= pci_addr7
+    ; mac= mac_addr7
+    ; bios_eth_order= 0 (* This impacts the initial position *)
+    ; multi_nic= false
+    }
+  in
+  let last_order =
+    [seen_dev0; seen_dev1; seen_dev2; seen_dev3; seen_dev4; seen_dev5]
+  in
+  (* Add two devices *)
+  let currents =
+    [dev0; dev1; dev2; dev3; dev4; dev5] |> plug dev6 |> plug dev7
+  in
+  let order = sort' ~currents ~rules:[] ~last_order in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "8 devices in the order" 8 (List.length order) ;
+  test_postion_and_present 0 true dev0 order ;
+  test_postion_and_present 1 true dev1 order ;
+  test_postion_and_present 2 true dev2 order ;
+  test_postion_and_present 3 true dev3 order ;
+  test_postion_and_present 4 true dev4 order ;
+  test_postion_and_present 5 true dev5 order ;
+  (* The positions of newly added devices are impacted by the bios_eth_order *)
+  test_postion_and_present 6 true dev7 order ;
+  test_postion_and_present 7 true dev6 order
+
+let test_removing () =
+  let last_order =
+    [seen_dev0; seen_dev1; seen_dev2; seen_dev3; seen_dev4; seen_dev5]
+  in
+  (* Remove two devices *)
+  let currents =
+    [dev0; dev1; dev2; dev3; dev4; dev5] |> unplug dev0 |> unplug dev1
+  in
+  let order = sort' ~currents ~rules:[] ~last_order in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+
+  Alcotest.(check int) "6 devices in the order" 6 (List.length order) ;
+  test_postion_and_present 0 false dev0 order ;
+  test_postion_and_present 1 false dev1 order ;
+  test_postion_and_present 2 true dev2 order ;
+  test_postion_and_present 3 true dev3 order ;
+  test_postion_and_present 4 true dev4 order ;
+  test_postion_and_present 5 true dev5 order
+
+let test_replug_removed () =
+  (* Mark the devices as removed. *)
+  let seen_dev0 = {seen_dev0 with present= false} in
+  let seen_dev1 = {seen_dev1 with present= false} in
+  let last_order =
+    [seen_dev0; seen_dev1; seen_dev2; seen_dev3; seen_dev4; seen_dev5]
+  in
+  let currents = [dev2; dev3; dev4; dev5] |> plug dev0 |> plug dev1 in
+  let order = sort' ~currents ~rules:[] ~last_order in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "6 devices in the order" 6 (List.length order) ;
+  test_postion_and_present 0 true dev0 order ;
+  test_postion_and_present 1 true dev1 order ;
+  test_postion_and_present 2 true dev2 order ;
+  test_postion_and_present 3 true dev3 order ;
+  test_postion_and_present 4 true dev4 order ;
+  test_postion_and_present 5 true dev5 order
+
+let test_multi_nic_inplace_reorder () =
+  (* The MAC addresses of multi_nic functions change *)
+  let mac_addr4' = Macaddr.of_string "01:02:c9:ed:fd:f0" |> Result.get_ok in
+  let mac_addr5' = Macaddr.of_string "01:02:c9:ed:fd:f1" |> Result.get_ok in
+  let dev4' = Dev.{dev4 with mac= mac_addr4'; bios_eth_order= 5} in
+  let dev5' = Dev.{dev5 with mac= mac_addr5'; bios_eth_order= 4} in
+  let last_order =
+    [seen_dev0; seen_dev1; seen_dev2; seen_dev3; seen_dev4; seen_dev5]
+  in
+  let currents = [dev0; dev1; dev2; dev3; dev4'; dev5'] in
+  let order = sort' ~currents ~rules:[] ~last_order in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "6 devices in the order" 6 (List.length order) ;
+  test_postion_and_present 0 true dev0 order ;
+  test_postion_and_present 1 true dev1 order ;
+  test_postion_and_present 2 true dev2 order ;
+  test_postion_and_present 3 true dev3 order ;
+  test_postion_and_present 4 true dev4' order ;
+  test_postion_and_present 5 true dev5' order
+
+let test_multi_nic_new_devices () =
+  let mac_addr6 = Macaddr.of_string "01:02:c9:ed:fd:f0" |> Result.get_ok in
+  let mac_addr7 = Macaddr.of_string "01:02:c9:ed:fd:f1" |> Result.get_ok in
+  let dev6 =
+    Dev.
+      {
+        name= "enp5s0d2"
+      ; pci= pci_addr4
+      ; mac= mac_addr6
+      ; bios_eth_order= 1
+      ; multi_nic= true (* multinic: share PCI address with dev4 *)
+      }
+  in
+  let dev7 =
+    Dev.
+      {
+        name= "enp5s0d3"
+      ; pci= pci_addr4
+      ; mac= mac_addr7
+      ; bios_eth_order= 0
+      ; multi_nic= true (* multinic: share PCI address with dev4*)
+      }
+  in
+  (* New devices are reported on the same PCI address.
+     It's equivalent to plugging new devices but locate at the same PCI address. *)
+  let last_order =
+    [seen_dev0; seen_dev1; seen_dev2; seen_dev3; seen_dev4; seen_dev5]
+  in
+  let currents =
+    [dev0; dev1; dev2; dev3; dev4; dev5] |> plug dev6 |> plug dev7
+  in
+  let order = sort' ~currents ~rules:[] ~last_order in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "8 devices in the order" 8 (List.length order) ;
+  test_postion_and_present 0 true dev0 order ;
+  test_postion_and_present 1 true dev1 order ;
+  test_postion_and_present 2 true dev2 order ;
+  test_postion_and_present 3 true dev3 order ;
+  test_postion_and_present 4 true dev4 order ;
+  test_postion_and_present 5 true dev5 order ;
+  test_postion_and_present 6 true dev6 order ;
+  test_postion_and_present 7 true dev7 order
+
+let test_pci_changes () =
+  let move_bus_by_1 pci_addr = Xcp_pci.{pci_addr with bus= pci_addr.bus + 1} in
+  let last_order =
+    [seen_dev0; seen_dev1; seen_dev2; seen_dev3; seen_dev4; seen_dev5]
+  in
+  let currents =
+    [dev0; dev1; dev2; dev3; dev4; dev5]
+    |> List.map (fun dev -> Dev.{dev with pci= move_bus_by_1 dev.pci})
+  in
+  let order = sort' ~currents ~rules:[] ~last_order in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "6 devices in the order" 6 (List.length order) ;
+  test_postion_and_present 0 true dev0 order ;
+  test_postion_and_present 1 true dev1 order ;
+  test_postion_and_present 2 true dev2 order ;
+  test_postion_and_present 3 true dev3 order ;
+  test_postion_and_present 4 true dev4 order ;
+  test_postion_and_present 5 true dev5 order
+
+let test_pci_addr_compare () =
+  let addr0 = Pciaddr.of_string "0000:01:0e.0" |> Result.get_ok in
+  let addr1 = Pciaddr.of_string "0000:01:0e.0" |> Result.get_ok in
+  let addr2 = Pciaddr.of_string "0000:01:0e.2" |> Result.get_ok in
+  let addr3 = Pciaddr.of_string "0000:01:0e.3" |> Result.get_ok in
+  let addr4 = Pciaddr.of_string "0000:01:0f.0" |> Result.get_ok in
+  let addr5 = Pciaddr.of_string "0000:02:0f.0" |> Result.get_ok in
+  let addr6 = Pciaddr.of_string "0001:02:0f.0" |> Result.get_ok in
+  Alcotest.(check bool) "equal" true (Pciaddr.compare addr0 addr1 = 0) ;
+  Alcotest.(check bool) "less than" true (Pciaddr.compare addr0 addr2 < 0) ;
+  Alcotest.(check bool) "greater than" true (Pciaddr.compare addr3 addr2 > 0) ;
+  Alcotest.(check bool) "greater than" true (Pciaddr.compare addr4 addr3 > 0) ;
+  Alcotest.(check bool) "greater than" true (Pciaddr.compare addr5 addr4 > 0) ;
+  Alcotest.(check bool) "less than" true (Pciaddr.compare addr6 addr5 > 0)
+
+let tests =
+  [
+    ( "test_known_cases"
+    , [
+        ("test_default", `Quick, test_default)
+      ; ("test_unstable_bios_eth_order", `Quick, test_unstable_bios_eth_order)
+      ; ("test_initial_mapping_via_mac", `Quick, test_initial_rules_via_mac)
+      ; ("test_initial_mapping_via_name", `Quick, test_initial_rules_via_label)
+      ; ("test_replacement", `Quick, test_replacement)
+      ; ("test_adding", `Quick, test_adding)
+      ; ("test_removing", `Quick, test_removing)
+      ; ("test_replug_removed", `Quick, test_replug_removed)
+      ; ( "test_multi_nic_inplace_reorder"
+        , `Quick
+        , test_multi_nic_inplace_reorder
+        )
+      ; ("test_multi_nic_new_devices", `Quick, test_multi_nic_new_devices)
+      ; ("test_pci_changes", `Quick, test_pci_changes)
+      ; ("test_pci_addr_compare", `Quick, test_pci_addr_compare)
+      ]
+    )
+  ]
diff --git a/ocaml/networkd/test/network_test.ml b/ocaml/networkd/test/test_network_device_order.mli
similarity index 74%
copy from ocaml/networkd/test/network_test.ml
copy to ocaml/networkd/test/test_network_device_order.mli
index 601fe8055..c32d2a7e6 100644
--- a/ocaml/networkd/test/network_test.ml
+++ b/ocaml/networkd/test/test_network_device_order.mli
@@ -1,5 +1,5 @@
 (*
- * Copyright (C) 2006-2013 Citrix Systems Inc.
+ * Copyright (c) Cloud Software Group, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published
@@ -12,7 +12,4 @@
  * GNU Lesser General Public License for more details.
  *)
 
-let () =
-  Debug.log_to_stdout () ;
-  Alcotest.run "base_suite"
-    (Network_test_lacp_properties.suite @ Test_jsonrpc_client.tests)
+val tests : unit Alcotest.test list
diff --git a/ocaml/networkd/test/test_network_device_order_inherited.ml b/ocaml/networkd/test/test_network_device_order_inherited.ml
new file mode 100644
index 000000000..1024c4c87
--- /dev/null
+++ b/ocaml/networkd/test/test_network_device_order_inherited.ml
@@ -0,0 +1,702 @@
+(*
+ * Copyright (c) Cloud Software Group, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation; version 2.1 only. with the special
+ * exception on linking described in file LICENSE.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *)
+
+open Network_device_order
+open Network_interface
+
+let pos_of_mac mac_addr order =
+  match List.find_opt (fun d -> d.mac = mac_addr) order with
+  | Some {position; _} ->
+      position
+  | _ ->
+      -1
+
+let present_of_mac mac order =
+  match List.find_opt (fun dev -> dev.mac = mac) order with
+  | Some {present; _} ->
+      present
+  | _ ->
+      failwith "Can't find the device!"
+
+let test_postion_and_present expected_position expected_present dev order =
+  let mac = dev.Dev.mac in
+  let name = Format.asprintf "Position assigned for %a" Macaddr.pp mac in
+  Alcotest.(check int) name expected_position (pos_of_mac mac order) ;
+  Alcotest.(check bool) name expected_present (present_of_mac mac order)
+
+let test_newhw_norules_1eth () =
+  let mac_addr = Macaddr.of_string "ab:cd:ef:12:34:56" |> Result.get_ok in
+  let dev0 =
+    {
+      Dev.name= "side-12-eth1"
+    ; pci= Pciaddr.of_string "0000:00:0f.0" |> Result.get_ok
+    ; mac= mac_addr
+    ; bios_eth_order= 0
+    ; multi_nic= false
+    }
+  in
+  let currents = [dev0] in
+  let order = sort' ~currents ~rules:[] ~last_order:[] in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "1 device in the order" 1 (List.length order) ;
+  test_postion_and_present 0 true dev0 order
+
+let test_newhw_norules_2eth () =
+  let dev0 =
+    {
+      Dev.name= "side-12-eth1"
+    ; pci= Pciaddr.of_string "0000:00:0f.0" |> Result.get_ok
+    ; mac= Macaddr.of_string "ab:cd:ef:12:34:56" |> Result.get_ok
+    ; bios_eth_order= 0
+    ; multi_nic= false
+    }
+  in
+  let dev1 =
+    {
+      Dev.name= "side-33-eth0"
+    ; pci= Pciaddr.of_string "0000:00:01.0" |> Result.get_ok
+    ; mac= Macaddr.of_string "ab:cd:ef:12:34:57" |> Result.get_ok
+    ; bios_eth_order= 1
+    ; multi_nic= false
+    }
+  in
+  let currents = [dev0; dev1] in
+  let order = sort' ~currents ~rules:[] ~last_order:[] in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "2 devices in the order" 2 (List.length order) ;
+  test_postion_and_present 0 true dev0 order ;
+  test_postion_and_present 1 true dev1 order
+
+let test_newhw_2srule_2eth () =
+  let mac_addr0 = Macaddr.of_string "12:34:56:78:90:12" |> Result.get_ok in
+  let mac_addr1 = Macaddr.of_string "ab:cd:ef:12:34:56" |> Result.get_ok in
+  let rules =
+    Rule.
+      [
+        {position= 0; index= Mac_addr mac_addr1}
+      ; {position= 1; index= Mac_addr mac_addr0}
+      ]
+  in
+  let dev0 =
+    {
+      Dev.name= "eth0"
+    ; pci= Pciaddr.of_string "0000:00:01.0" |> Result.get_ok
+    ; mac= mac_addr0
+    ; bios_eth_order= 1
+    ; multi_nic= false
+    }
+  in
+  let dev1 =
+    {
+      Dev.name= "side-12-eth1"
+    ; pci= Pciaddr.of_string "0000:00:0f.0" |> Result.get_ok
+    ; mac= mac_addr1
+    ; bios_eth_order= 0
+    ; multi_nic= false
+    }
+  in
+  let currents = [dev0; dev1] in
+  let order = sort' ~currents ~rules ~last_order:[] in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  test_postion_and_present 1 true dev0 order ;
+  test_postion_and_present 0 true dev1 order
+
+let test_nosrules_1eth_incorrect_udev () =
+  let mac_addr = Macaddr.of_string "ab:cd:ef:12:34:56" |> Result.get_ok in
+  let pci_addr = Pciaddr.of_string "0000:00:0f.0" |> Result.get_ok in
+  let dev0 =
+    {
+      Dev.name= "side-12-eth0"
+    ; pci= pci_addr
+    ; mac= mac_addr
+    ; bios_eth_order= 0
+    ; multi_nic= false
+    }
+  in
+  let currents = [dev0] in
+  let seen_dev0 =
+    {name= "eth2"; pci= pci_addr; mac= mac_addr; position= 3; present= true}
+  in
+  let last_order = [seen_dev0] in
+  let order = sort' ~currents ~rules:[] ~last_order in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  test_postion_and_present 3 true dev0 order
+
+let test_1srule_1eth_1last_correct_udev () =
+  let mac_addr = Macaddr.of_string "ab:cd:ef:12:34:56" |> Result.get_ok in
+  let pci_addr = Pciaddr.of_string "0000:00:0f.0" |> Result.get_ok in
+  let dev0 =
+    {
+      Dev.name= "eth1"
+    ; pci= pci_addr
+    ; mac= mac_addr
+    ; bios_eth_order= 1
+    ; multi_nic= false
+    }
+  in
+  let currents = [dev0] in
+  let rules = Rule.[{position= 0; index= Mac_addr mac_addr}] in
+  let seen_dev0 =
+    {name= "eth1"; pci= pci_addr; mac= mac_addr; position= 1; present= true}
+  in
+  let last_order = [seen_dev0] in
+  let order = sort' ~currents ~rules ~last_order in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "1 device in the order" 1 (List.length order) ;
+  test_postion_and_present 0 true dev0 order
+
+let test_1srule_1eth_already_complete () =
+  let mac_addr = Macaddr.of_string "00:13:72:2d:2a:ec" |> Result.get_ok in
+  let pci_addr = Pciaddr.of_string "0000:04:00.0" |> Result.get_ok in
+  let dev0 =
+    {
+      Dev.name= "eth0"
+    ; pci= pci_addr
+    ; mac= mac_addr
+    ; bios_eth_order= 0
+    ; multi_nic= false
+    }
+  in
+  let currents = [dev0] in
+  let rules = Rule.[{position= 0; index= Mac_addr mac_addr}] in
+  let order = sort' ~currents ~rules ~last_order:[] in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "1 device in the order" 1 (List.length order) ;
+  test_postion_and_present 0 true dev0 order
+
+let test_1drule_1eth_already_complete () =
+  let mac_addr = Macaddr.of_string "00:13:72:2d:2a:ec" |> Result.get_ok in
+  let pci_addr = Pciaddr.of_string "0000:04:00.0" |> Result.get_ok in
+  let dev0 =
+    {
+      Dev.name= "eth0"
+    ; pci= pci_addr
+    ; mac= mac_addr
+    ; bios_eth_order= 0
+    ; multi_nic= false
+    }
+  in
+  let currents = [dev0] in
+  let seen_dev0 =
+    {name= "eth0"; pci= pci_addr; mac= mac_addr; position= 0; present= true}
+  in
+  let last_order = [seen_dev0] in
+  let order = sort' ~currents ~rules:[] ~last_order in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "1 device in the order" 1 (List.length order) ;
+  test_postion_and_present 0 true dev0 order
+
+let test_usecase1 () =
+  let mac_addr0 = Macaddr.of_string "01:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr1 = Macaddr.of_string "11:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr2 = Macaddr.of_string "21:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr3 = Macaddr.of_string "31:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr4 = Macaddr.of_string "41:23:45:67:89:01" |> Result.get_ok in
+  let pci_addr0 = Pciaddr.of_string "0000:01:00.0" |> Result.get_ok in
+  let pci_addr1 = Pciaddr.of_string "0000:02:00.0" |> Result.get_ok in
+  let pci_addr2 = Pciaddr.of_string "0000:03:00.0" |> Result.get_ok in
+  let pci_addr3 = Pciaddr.of_string "0000:04:00.0" |> Result.get_ok in
+  let pci_addr4 = Pciaddr.of_string "0000:05:00.0" |> Result.get_ok in
+
+  let dev0 =
+    {
+      Dev.name= "eth0"
+    ; pci= pci_addr0
+    ; mac= mac_addr0
+    ; bios_eth_order= 0
+    ; multi_nic= false
+    }
+  in
+  let dev1 =
+    {
+      Dev.name= "eth1"
+    ; pci= pci_addr1
+    ; mac= mac_addr1
+    ; bios_eth_order= 1
+    ; multi_nic= false
+    }
+  in
+  let dev2 =
+    {
+      Dev.name= "eth2"
+    ; pci= pci_addr2
+    ; mac= mac_addr2
+    ; bios_eth_order= 2
+    ; multi_nic= false
+    }
+  in
+  let dev3 =
+    {
+      Dev.name= "eth3"
+    ; pci= pci_addr3
+    ; mac= mac_addr3
+    ; bios_eth_order= 3
+    ; multi_nic= false
+    }
+  in
+  let dev4 =
+    {
+      Dev.name= "eth4"
+    ; pci= pci_addr4
+    ; mac= mac_addr4
+    ; bios_eth_order= 4
+    ; multi_nic= false
+    }
+  in
+  let currents = [dev0; dev1; dev2; dev3; dev4] in
+  let seen_dev0 =
+    {name= "eth0"; pci= pci_addr0; mac= mac_addr0; position= 0; present= true}
+  in
+  let seen_dev1 =
+    {name= "eth1"; pci= pci_addr1; mac= mac_addr1; position= 1; present= true}
+  in
+  let seen_dev2 =
+    {name= "eth2"; pci= pci_addr2; mac= mac_addr2; position= 2; present= true}
+  in
+  let seen_dev3 =
+    {name= "eth3"; pci= pci_addr3; mac= mac_addr3; position= 3; present= true}
+  in
+  let seen_dev4 =
+    {name= "eth4"; pci= pci_addr4; mac= mac_addr4; position= 4; present= true}
+  in
+  let last_order = [seen_dev0; seen_dev1; seen_dev2; seen_dev3; seen_dev4] in
+  let order = sort' ~currents ~rules:[] ~last_order in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "5 devices in the order" 5 (List.length order) ;
+  test_postion_and_present 0 true dev0 order ;
+  test_postion_and_present 1 true dev1 order ;
+  test_postion_and_present 2 true dev2 order ;
+  test_postion_and_present 3 true dev3 order ;
+  test_postion_and_present 4 true dev4 order
+
+let test_usecase5 () =
+  let mac_addr0' = Macaddr.of_string "02:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr1' = Macaddr.of_string "12:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr2' = Macaddr.of_string "22:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr3' = Macaddr.of_string "32:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr4' = Macaddr.of_string "42:23:45:67:89:01" |> Result.get_ok in
+
+  let mac_addr0 = Macaddr.of_string "01:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr1 = Macaddr.of_string "11:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr2 = Macaddr.of_string "21:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr3 = Macaddr.of_string "31:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr4 = Macaddr.of_string "41:23:45:67:89:01" |> Result.get_ok in
+
+  let pci_addr0 = Pciaddr.of_string "0000:01:00.0" |> Result.get_ok in
+  let pci_addr1 = Pciaddr.of_string "0000:02:00.0" |> Result.get_ok in
+  let pci_addr2 = Pciaddr.of_string "0000:03:00.0" |> Result.get_ok in
+  let pci_addr3 = Pciaddr.of_string "0000:04:00.0" |> Result.get_ok in
+  let pci_addr4 = Pciaddr.of_string "0000:05:00.0" |> Result.get_ok in
+
+  let dev0 =
+    {
+      Dev.name= "side-1-eth0"
+    ; pci= pci_addr0
+    ; mac= mac_addr0'
+    ; bios_eth_order= 0
+    ; multi_nic= false
+    }
+  in
+  let dev1 =
+    {
+      Dev.name= "side-34-eth1"
+    ; pci= pci_addr1
+    ; mac= mac_addr1'
+    ; bios_eth_order= 1
+    ; multi_nic= false
+    }
+  in
+  let dev2 =
+    {
+      Dev.name= "side-71-eth2"
+    ; pci= pci_addr2
+    ; mac= mac_addr2'
+    ; bios_eth_order= 2
+    ; multi_nic= false
+    }
+  in
+  let dev3 =
+    {
+      Dev.name= "side-3012-eth3"
+    ; pci= pci_addr3
+    ; mac= mac_addr3'
+    ; bios_eth_order= 3
+    ; multi_nic= false
+    }
+  in
+  let dev4 =
+    {
+      Dev.name= "side-4332-eth4"
+    ; pci= pci_addr4
+    ; mac= mac_addr4'
+    ; bios_eth_order= 4
+    ; multi_nic= false
+    }
+  in
+  let currents = [dev0; dev1; dev2; dev3; dev4] in
+  let seen_dev0 =
+    {name= "eth0"; pci= pci_addr0; mac= mac_addr0; position= 0; present= true}
+  in
+  let seen_dev1 =
+    {name= "eth1"; pci= pci_addr1; mac= mac_addr1; position= 1; present= true}
+  in
+  let seen_dev2 =
+    {name= "eth2"; pci= pci_addr2; mac= mac_addr2; position= 2; present= true}
+  in
+  let seen_dev3 =
+    {name= "eth3"; pci= pci_addr3; mac= mac_addr3; position= 3; present= true}
+  in
+  let seen_dev4 =
+    {name= "eth4"; pci= pci_addr4; mac= mac_addr4; position= 4; present= true}
+  in
+  let last_order = [seen_dev0; seen_dev1; seen_dev2; seen_dev3; seen_dev4] in
+  let order = sort' ~currents ~rules:[] ~last_order in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "5 devices in the order" 5 (List.length order) ;
+  test_postion_and_present 0 true dev0 order ;
+  test_postion_and_present 1 true dev1 order ;
+  test_postion_and_present 2 true dev2 order ;
+  test_postion_and_present 3 true dev3 order ;
+  test_postion_and_present 4 true dev4 order
+
+let test_CA_94279 () =
+  let mac_addr0 = Macaddr.of_string "00:1b:21:aa:ef:f0" |> Result.get_ok in
+  let mac_addr1 = Macaddr.of_string "00:1b:21:aa:ef:f1" |> Result.get_ok in
+  let mac_addr2 = Macaddr.of_string "00:1b:21:aa:ef:f4" |> Result.get_ok in
+  let mac_addr3 = Macaddr.of_string "00:1b:21:aa:ef:f5" |> Result.get_ok in
+  let mac_addr4 = Macaddr.of_string "60:eb:69:ed:9a:16" |> Result.get_ok in
+  let mac_addr5 = Macaddr.of_string "60:eb:69:ed:9a:17" |> Result.get_ok in
+
+  let pci_addr0 = Pciaddr.of_string "0000:03:00.0" |> Result.get_ok in
+  let pci_addr1 = Pciaddr.of_string "0000:03:00.1" |> Result.get_ok in
+  let pci_addr2 = Pciaddr.of_string "0000:04:00.0" |> Result.get_ok in
+  let pci_addr3 = Pciaddr.of_string "0000:04:00.1" |> Result.get_ok in
+  let pci_addr4 = Pciaddr.of_string "0000:06:00.0" |> Result.get_ok in
+  let pci_addr5 = Pciaddr.of_string "0000:06:00.1" |> Result.get_ok in
+
+  let dev0 =
+    {
+      Dev.name= "side-1-eth0"
+    ; pci= pci_addr0
+    ; mac= mac_addr0
+    ; bios_eth_order= 2
+    ; multi_nic= false
+    }
+  in
+  let dev1 =
+    {
+      Dev.name= "side-2-eth1"
+    ; pci= pci_addr1
+    ; mac= mac_addr1
+    ; bios_eth_order= 3
+    ; multi_nic= false
+    }
+  in
+  let dev2 =
+    {
+      Dev.name= "side-3-eth2"
+    ; pci= pci_addr2
+    ; mac= mac_addr2
+    ; bios_eth_order= 4
+    ; multi_nic= false
+    }
+  in
+  let dev3 =
+    {
+      Dev.name= "side-4-eth3"
+    ; pci= pci_addr3
+    ; mac= mac_addr3
+    ; bios_eth_order= 5
+    ; multi_nic= false
+    }
+  in
+  let dev4 =
+    {
+      Dev.name= "side-5-eth4"
+    ; pci= pci_addr4
+    ; mac= mac_addr4
+    ; bios_eth_order= 0
+    ; multi_nic= false
+    }
+  in
+  let dev5 =
+    {
+      Dev.name= "side-6-eth5"
+    ; pci= pci_addr5
+    ; mac= mac_addr5
+    ; bios_eth_order= 1
+    ; multi_nic= false
+    }
+  in
+  let currents = [dev0; dev1; dev2; dev3; dev4; dev5] in
+  let order = sort' ~currents ~rules:[] ~last_order:[] in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "6 devices in the order" 6 (List.length order) ;
+  test_postion_and_present 2 true dev0 order ;
+  test_postion_and_present 3 true dev1 order ;
+  test_postion_and_present 4 true dev2 order ;
+  test_postion_and_present 5 true dev3 order ;
+  test_postion_and_present 0 true dev4 order ;
+  test_postion_and_present 1 true dev5 order
+
+let test_rshp_new_hardware () =
+  let mac_addr0' = Macaddr.of_string "02:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr1' = Macaddr.of_string "12:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr2' = Macaddr.of_string "22:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr3' = Macaddr.of_string "32:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr4' = Macaddr.of_string "32:23:45:67:89:02" |> Result.get_ok in
+
+  let pci_addr0 = Pciaddr.of_string "0000:01:00.0" |> Result.get_ok in
+  let pci_addr1 = Pciaddr.of_string "0000:02:00.0" |> Result.get_ok in
+  let pci_addr2 = Pciaddr.of_string "0000:03:00.0" |> Result.get_ok in
+  let pci_addr3 = Pciaddr.of_string "0000:04:00.0" |> Result.get_ok in
+
+  let mac_addr0 = Macaddr.of_string "01:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr1 = Macaddr.of_string "11:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr2 = Macaddr.of_string "21:23:45:67:89:01" |> Result.get_ok in
+  let mac_addr3 = Macaddr.of_string "31:23:45:67:89:02" |> Result.get_ok in
+  let mac_addr4 = Macaddr.of_string "31:23:45:67:89:01" |> Result.get_ok in
+
+  let dev0 =
+    {
+      Dev.name= "side-1-eth0"
+    ; pci= pci_addr0
+    ; mac= mac_addr0'
+    ; bios_eth_order= 0
+    ; multi_nic= false
+    }
+  in
+
+  let dev1 =
+    {
+      Dev.name= "side-34-eth1"
+    ; pci= pci_addr1
+    ; mac= mac_addr1'
+    ; bios_eth_order= 1
+    ; multi_nic= false
+    }
+  in
+  let dev2 =
+    {
+      Dev.name= "side-71-eth2"
+    ; pci= pci_addr2
+    ; mac= mac_addr2'
+    ; bios_eth_order= 2
+    ; multi_nic= false
+    }
+  in
+
+  let dev3 =
+    {
+      Dev.name= "side-3012-eth3"
+    ; pci= pci_addr3
+    ; mac= mac_addr3'
+    ; bios_eth_order= 3
+    ; multi_nic= true
+    }
+  in
+  let dev4 =
+    {
+      Dev.name= "side-4332-eth4"
+    ; pci= pci_addr3
+    ; mac= mac_addr4'
+    ; bios_eth_order= 4
+    ; multi_nic= true
+    }
+  in
+  let seen_dev0 =
+    {name= "eth0"; pci= pci_addr0; mac= mac_addr0; position= 0; present= true}
+  in
+  let seen_dev1 =
+    {name= "eth1"; pci= pci_addr1; mac= mac_addr1; position= 1; present= true}
+  in
+  let seen_dev2 =
+    {name= "eth2"; pci= pci_addr2; mac= mac_addr2; position= 2; present= true}
+  in
+  let seen_dev3 =
+    {name= "eth3"; pci= pci_addr3; mac= mac_addr3; position= 3; present= true}
+  in
+  let seen_dev4 =
+    {name= "eth4"; pci= pci_addr3; mac= mac_addr4; position= 4; present= true}
+  in
+  let currents = [dev0; dev1; dev2; dev3; dev4] in
+  let last_order = [seen_dev0; seen_dev1; seen_dev2; seen_dev3; seen_dev4] in
+  let order = sort' ~currents ~rules:[] ~last_order in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "5 devices in the order" 5 (List.length order) ;
+  test_postion_and_present 0 true dev0 order ;
+  test_postion_and_present 1 true dev1 order ;
+  test_postion_and_present 2 true dev2 order ;
+  test_postion_and_present 4 true dev3 order ;
+  test_postion_and_present 3 true dev4 order
+
+let test_bad_biosdevname_order () =
+  let pci_addr0 = Pciaddr.of_string "0000:01:00.0" |> Result.get_ok in
+  let pci_addr1 = Pciaddr.of_string "0000:02:00.0" |> Result.get_ok in
+  let pci_addr4 = Pciaddr.of_string "0000:03:00.0" |> Result.get_ok in
+  let pci_addr5 = Pciaddr.of_string "0000:04:00.0" |> Result.get_ok in
+  let pci_addr8 = Pciaddr.of_string "0000:05:00.0" |> Result.get_ok in
+
+  let mac_addr0 = Macaddr.of_string "00:00:00:00:00:01" |> Result.get_ok in
+  let mac_addr1 = Macaddr.of_string "00:00:44:00:01:01" |> Result.get_ok in
+  let mac_addr2 = Macaddr.of_string "00:00:44:00:01:02" |> Result.get_ok in
+  let mac_addr3 = Macaddr.of_string "00:00:44:00:01:03" |> Result.get_ok in
+  let mac_addr4 = Macaddr.of_string "00:00:00:00:02:01" |> Result.get_ok in
+  let mac_addr5 = Macaddr.of_string "00:00:22:00:03:01" |> Result.get_ok in
+  let mac_addr6 = Macaddr.of_string "00:00:22:00:03:02" |> Result.get_ok in
+  let mac_addr7 = Macaddr.of_string "00:00:22:00:03:03" |> Result.get_ok in
+  let mac_addr8 = Macaddr.of_string "00:00:00:00:04:01" |> Result.get_ok in
+
+  let dev0 =
+    {
+      Dev.name= "side-0-eth0"
+    ; pci= pci_addr0
+    ; mac= mac_addr0
+    ; bios_eth_order= 0
+    ; multi_nic= false
+    }
+  in
+  let dev1 =
+    {
+      Dev.name= "side-0-eth2"
+    ; pci= pci_addr1
+    ; mac= mac_addr1
+    ; bios_eth_order= 2
+    ; multi_nic= true
+    }
+  in
+  let dev2 =
+    {
+      Dev.name= "side-0-eth6"
+    ; pci= pci_addr1
+    ; mac= mac_addr2
+    ; bios_eth_order= 6
+    ; multi_nic= true
+    }
+  in
+  let dev3 =
+    {
+      Dev.name= "side-0-eth1"
+    ; pci= pci_addr1
+    ; mac= mac_addr3
+    ; bios_eth_order= 1
+    ; multi_nic= true
+    }
+  in
+  let dev4 =
+    {
+      Dev.name= "side-0-eth4"
+    ; pci= pci_addr4
+    ; mac= mac_addr4
+    ; bios_eth_order= 4
+    ; multi_nic= true
+    }
+  in
+  let dev5 =
+    {
+      Dev.name= "side-0-eth5"
+    ; pci= pci_addr5
+    ; mac= mac_addr5
+    ; bios_eth_order= 7
+    ; multi_nic= true
+    }
+  in
+  let dev6 =
+    {
+      Dev.name= "side-0-eth3"
+    ; pci= pci_addr5
+    ; mac= mac_addr6
+    ; bios_eth_order= 3
+    ; multi_nic= true
+    }
+  in
+  let dev7 =
+    {
+      Dev.name= "side-0-eth7"
+    ; pci= pci_addr5
+    ; mac= mac_addr7
+    ; bios_eth_order= 5
+    ; multi_nic= true
+    }
+  in
+  let dev8 =
+    {
+      Dev.name= "side-0-eth8"
+    ; pci= pci_addr8
+    ; mac= mac_addr8
+    ; bios_eth_order= 8
+    ; multi_nic= false
+    }
+  in
+  let currents = [dev0; dev1; dev2; dev3; dev4; dev5; dev6; dev7; dev8] in
+  let order = sort' ~currents ~rules:[] ~last_order:[] in
+  Alcotest.(check bool) "is Ok" true (Result.is_ok order) ;
+  let order = Result.get_ok order in
+  Alcotest.(check int) "9 devices in the order" 9 (List.length order) ;
+  test_postion_and_present 0 true dev0 order ;
+  test_postion_and_present 1 true dev1 order ;
+  test_postion_and_present 2 true dev2 order ;
+  test_postion_and_present 6 true dev3 order ;
+  test_postion_and_present 4 true dev4 order ;
+  test_postion_and_present 3 true dev5 order ;
+  test_postion_and_present 5 true dev6 order ;
+  test_postion_and_present 7 true dev7 order ;
+  test_postion_and_present 8 true dev8 order
+
+let tests =
+  [
+    ( "test_simple_logic"
+    , [
+        ("test_newhw_norules_1eth", `Quick, test_newhw_norules_1eth)
+      ; ("test_newhw_norules_2eth", `Quick, test_newhw_norules_2eth)
+      ; ("test_newhw_2srule_2eth", `Quick, test_newhw_2srule_2eth)
+      ; ( "test_nosrules_1eth_incorrect_udev"
+        , `Quick
+        , test_nosrules_1eth_incorrect_udev
+        )
+      ; ( "test_1srule_1eth_1last_correct_udev"
+        , `Quick
+        , test_1srule_1eth_1last_correct_udev
+        )
+      ; ( "test_1srule_1eth_already_complete"
+        , `Quick
+        , test_1srule_1eth_already_complete
+        )
+      ; ( "test_1drule_1eth_already_complete"
+        , `Quick
+        , test_1drule_1eth_already_complete
+        )
+      ]
+    )
+  ; ( "test_use_cases"
+    , [
+        ("test_usecase1", `Quick, test_usecase1)
+      ; ("test_usecase5", `Quick, test_usecase5)
+      ; ("test_CA_94279", `Quick, test_CA_94279)
+      ; ("test_rshp_new_hardware", `Quick, test_rshp_new_hardware)
+      ; ("test_bad_biosdevname_order", `Quick, test_bad_biosdevname_order)
+      ]
+    )
+  ]
diff --git a/ocaml/networkd/test/network_test.ml b/ocaml/networkd/test/test_network_device_order_inherited.mli
similarity index 74%
copy from ocaml/networkd/test/network_test.ml
copy to ocaml/networkd/test/test_network_device_order_inherited.mli
index 601fe8055..c32d2a7e6 100644
--- a/ocaml/networkd/test/network_test.ml
+++ b/ocaml/networkd/test/test_network_device_order_inherited.mli
@@ -1,5 +1,5 @@
 (*
- * Copyright (C) 2006-2013 Citrix Systems Inc.
+ * Copyright (c) Cloud Software Group, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published
@@ -12,7 +12,4 @@
  * GNU Lesser General Public License for more details.
  *)
 
-let () =
-  Debug.log_to_stdout () ;
-  Alcotest.run "base_suite"
-    (Network_test_lacp_properties.suite @ Test_jsonrpc_client.tests)
+val tests : unit Alcotest.test list
diff --git a/ocaml/xapi-idl/network/cli-help.t b/ocaml/xapi-idl/network/cli-help.t
index b8878a904..0fda87d57 100644
--- a/ocaml/xapi-idl/network/cli-help.t
+++ b/ocaml/xapi-idl/network/cli-help.t
@@ -59,6 +59,9 @@
          Network.Interface.get_dns [OPTION]… string name
              Get DNS
   
+         Network.Interface.get_interface_positions [OPTION]… string
+             Get list of interface names and their positions
+  
          Network.Interface.get_ipv4_addr [OPTION]… string name
              Get list of IPv4 addresses of the interface
   
diff --git a/ocaml/xapi-idl/network/dune b/ocaml/xapi-idl/network/dune
index d1016ae88..01ec12098 100644
--- a/ocaml/xapi-idl/network/dune
+++ b/ocaml/xapi-idl/network/dune
@@ -11,6 +11,7 @@
    xapi-idl
    xapi-log
    ipaddr
+   macaddr
  )
  (wrapped false)
  (preprocess (pps ppx_deriving_rpc)))
diff --git a/ocaml/xapi-idl/network/network_interface.ml b/ocaml/xapi-idl/network/network_interface.ml
index 2f3368fc1..7bdf8b141 100644
--- a/ocaml/xapi-idl/network/network_interface.ml
+++ b/ocaml/xapi-idl/network/network_interface.ml
@@ -81,6 +81,34 @@ module Unix = struct
       }
 end
 
+module Macaddr = struct
+  include Macaddr
+
+  let typ_of =
+    Rpc.Types.Abstract
+      {
+        aname= "macaddr"
+      ; test_data= [Macaddr.of_string_exn "ca:fe:ba:be:ee:ee"]
+      ; rpc_of= (fun t -> Rpc.String (Macaddr.to_octets t))
+      ; of_rpc=
+          (function
+          | Rpc.String s ->
+              Macaddr.of_octets s
+              |> Result.map_error (fun (`Msg e) ->
+                     `Msg (Printf.sprintf "typ_of_macaddr: %s" e)
+                 )
+          | r ->
+              Error
+                (`Msg
+                  (Printf.sprintf
+                     "typ_of_macaddr: expectd rpc string but got %s"
+                     (Rpc.to_string r)
+                  )
+                  )
+          )
+      }
+end
+
 (** {2 Types} *)
 
 type debug_info = string [@@deriving rpcty]
@@ -91,6 +119,8 @@ type port = string [@@deriving rpcty]
 
 type bridge = string [@@deriving rpcty]
 
+type mac_address = Macaddr.t [@@deriving rpcty]
+
 (* rpcty cannot handle polymorphic variant, so change the definition to variant *)
 type dhcp_options = Set_gateway | Set_dns [@@deriving rpcty]
 
@@ -184,11 +214,21 @@ type bridge_config_t = {
 }
 [@@deriving rpcty]
 
+type ordered_iface = {
+    name: iface
+  ; position: int
+  ; mac: mac_address
+  ; pci: Xcp_pci.address
+  ; present: bool
+}
+[@@deriving rpcty]
+
 type config_t = {
     interface_config: (iface * interface_config_t) list [@default []]
   ; bridge_config: (bridge * bridge_config_t) list [@default []]
   ; gateway_interface: iface option [@default None]
   ; dns_interface: iface option [@default None]
+  ; interface_order: ordered_iface list option [@default None]
 }
 [@@deriving rpcty]
 
@@ -226,6 +266,7 @@ let default_config =
   ; bridge_config= []
   ; gateway_interface= None
   ; dns_interface= None
+  ; interface_order= None
   }
 
 (** {2 Configuration manipulation} *)
@@ -379,6 +420,18 @@ module Interface_API (R : RPC) = struct
         ["Get list of all interface names"]
         (debug_info_p @-> unit_p @-> returning iface_list_p err)
 
+    let get_interface_positions =
+      let module T = struct
+        type _iface_position_list_t = (iface * int) list [@@deriving rpcty]
+      end in
+      let iface_position_list_p =
+        Param.mk ~description:["interface postion list"]
+          T._iface_position_list_t
+      in
+      declare "Interface.get_interface_positions"
+        ["Get list of interface names and their positions"]
+        (debug_info_p @-> unit_p @-> returning iface_position_list_p err)
+
     let exists =
       let result = Param.mk ~description:["existence"] Types.bool in
       declare "Interface.exists"
diff --git a/ocaml/xapi/helpers.ml b/ocaml/xapi/helpers.ml
index 121c1c179..70bcc092d 100644
--- a/ocaml/xapi/helpers.ml
+++ b/ocaml/xapi/helpers.ml
@@ -129,8 +129,11 @@ let call_script ?(log_output = Always) ?env ?stdin ?timeout script args =
       raise e
 
 (** Construct a descriptive network name (used as name_label) for a give network interface. *)
-let choose_network_name_for_pif device =
-  Printf.sprintf "Pool-wide network associated with %s" device
+let choose_network_name_for_pif device = function
+  | Some pos ->
+      Printf.sprintf "Pool-wide network %d" pos
+  | None ->
+      Printf.sprintf "Pool-wide network associated with %s" device
 
 (* !! FIXME - trap proper MISSINGREFERENCE exception when this has been defined *)
 (* !! FIXME(2) - this code could be shared with the CLI? *)
diff --git a/ocaml/xapi/xapi_pif.ml b/ocaml/xapi/xapi_pif.ml
index eaf4b37b8..238cf85e7 100644
--- a/ocaml/xapi/xapi_pif.ml
+++ b/ocaml/xapi/xapi_pif.ml
@@ -38,7 +38,118 @@ let get_device_pci ~__context ~host ~device =
   | _ ->
       Ref.null
 
-let refresh_internal ~__context ~self =
+let bridge_naming_convention (device : string) (pos_opt : int option) =
+  match pos_opt with
+  | Some index ->
+      "xenbr" ^ string_of_int index
+  | None ->
+      "br" ^ device
+
+let n_of_xenbrn_opt bridge =
+  try Scanf.sscanf bridge "xenbr%d%!" Option.some with _ -> None
+
+type tables = {
+    device_to_position_table: (string * int) list
+  ; device_to_mac_table: (string * string) list
+  ; pif_to_device_table: (API.ref_PIF * string) list
+}
+
+let get_physical_pif_device ~__context ~interface_tables ~pif_rec =
+  let dbg = Context.string_of_task __context in
+  let find_name_by_position position original_name =
+    match
+      List.find_map
+        (fun (name, pos) -> if pos = position then Some name else None)
+        interface_tables.device_to_position_table
+    with
+    | Some name ->
+        if name <> original_name then
+          info "PIF: device name changed from %s to %s" original_name name ;
+        name
+    | None -> (
+        (* This clause should be unlikely to happen, if enter this, check the if
+           we can get mac from networkd. If yes there may be a bug *)
+        warn "PIF %s: no device found for position %d" original_name position ;
+        try
+          let mac = Net.Interface.get_mac dbg original_name in
+          error
+            "PIF %s: no device found for position %d, but get MAC address %s , \
+             there may be a bug in networkd sorting."
+            original_name position mac ;
+          original_name
+        with _ -> original_name
+      )
+  in
+  if pif_rec.API.pIF_physical then (
+    let bridge =
+      Db.Network.get_bridge ~__context ~self:pif_rec.API.pIF_network
+    in
+    match n_of_xenbrn_opt bridge with
+    | Some position ->
+        find_name_by_position position pif_rec.API.pIF_device
+    | None ->
+        info "PIF %s: no position found for this device" pif_rec.API.pIF_device ;
+        pif_rec.API.pIF_device
+  ) else
+    pif_rec.API.pIF_device
+
+(* For different pif types, get the proper device name
+   - Physical: maybe change, need to lookup device_to_position_table
+   - VLAN_untagged: get the underlying physical PIF device
+   - Network_sriov_logical: get the underlying physical PIF device
+   - Tunnel_access: tunnel<N>, no need to change
+   - Bond_master: bond<N>, no need to change
+*)
+let get_pif_device ~__context ~interface_tables ~pif_rec =
+  match Xapi_pif_helpers.get_pif_topo ~__context ~pif_rec with
+  | VLAN_untagged _ :: Network_sriov_logical _ :: Physical pif :: _
+  | VLAN_untagged _ :: Physical pif :: _
+  | Network_sriov_logical _ :: Physical pif :: _
+  | Physical pif :: _ ->
+      get_physical_pif_device ~__context ~interface_tables ~pif_rec:pif
+  | _ ->
+      pif_rec.API.pIF_device
+
+let make_tables ~__context ~host =
+  let dbg = Context.string_of_task __context in
+  let device_to_position_table = Net.Interface.get_interface_positions dbg () in
+  let device_to_mac_table =
+    List.filter_map
+      (fun name ->
+        if Net.Interface.is_physical dbg name then
+          Some (name, Net.Interface.get_mac dbg name)
+        else
+          None
+      )
+      (Net.Interface.get_all dbg ())
+  in
+  (* Get all PIFs on this host *)
+  let pif_to_device_table =
+    Db.PIF.get_records_where ~__context
+      ~expr:
+        (And
+           ( Eq (Field "host", Literal (Ref.string_of host))
+           , Eq (Field "physical", Literal "true")
+           )
+        )
+    |> List.map (fun (pref, prec) -> (pref, prec.API.pIF_device))
+  in
+  debug "tables: device_to_position_table = %s"
+    (String.concat "; "
+       (List.map
+          (fun (d, p) -> d ^ ":" ^ string_of_int p)
+          device_to_position_table
+       )
+    ) ;
+  debug "tables: device_to_mac_table = %s"
+    (String.concat "; "
+       (List.map (fun (d, m) -> d ^ ":" ^ m) device_to_mac_table)
+    ) ;
+  debug "tables: pif_to_device_table = %s"
+    (String.concat "; " (List.map snd pif_to_device_table)) ;
+  {device_to_position_table; device_to_mac_table; pif_to_device_table}
+
+let refresh_internal ~__context ~interface_tables ~self =
   let dbg = Context.string_of_task __context in
   let pif = Db.PIF.get_record ~__context ~self in
   let network =
@@ -51,11 +162,16 @@ let refresh_internal ~__context ~self =
       pif.API.pIF_network
   in
   let bridge = Db.Network.get_bridge ~__context ~self:network in
+  (* Pif device name maybe change. Look up device_to_position table to get the
+     new device name. *)
+  let pif_device_name =
+    get_pif_device ~__context ~interface_tables ~pif_rec:pif
+  in
   (* Update the specified PIF field in the database, if
-     	 * and only if a corresponding value can be read from
-     	 * the underlying network device and if that value is
-     	 * different from the current field value.
-  *)
+   * and only if a corresponding value can be read from
+   * the underlying network device and if that value is
+   * different from the current field value.
+   *)
   let maybe_update_database field_name db_value set_field get_value print_value
       =
     Option.iter
@@ -68,57 +184,42 @@ let refresh_internal ~__context ~self =
       )
       (try Some (get_value ()) with _ -> None)
   in
-  if pif.API.pIF_physical then
+  maybe_update_database "device" pif.API.pIF_device Db.PIF.set_device
+    (fun () -> pif_device_name)
+    Fun.id ;
+  if pif.API.pIF_physical then (
     maybe_update_database "MAC" pif.API.pIF_MAC Db.PIF.set_MAC
-      (fun () -> Net.Interface.get_mac dbg pif.API.pIF_device)
-      (fun x -> x) ;
-  maybe_update_database "PCI" pif.API.pIF_PCI Db.PIF.set_PCI
-    (fun () ->
-      get_device_pci ~__context ~host:pif.API.pIF_host
-        ~device:pif.API.pIF_device
-    )
-    Ref.string_of ;
-  maybe_update_database "MTU" pif.API.pIF_MTU Db.PIF.set_MTU
-    (fun () -> Int64.of_int (Net.Interface.get_mtu dbg bridge))
-    Int64.to_string ;
-  if pif.API.pIF_physical then
+      (fun () -> Net.Interface.get_mac dbg pif_device_name)
+      Fun.id ;
     maybe_update_database "capabilities" pif.API.pIF_capabilities
       Db.PIF.set_capabilities
-      (fun () -> Net.Interface.get_capabilities dbg pif.API.pIF_device)
+      (fun () -> Net.Interface.get_capabilities dbg pif_device_name)
       (String.concat "; ")
-
-let refresh ~__context ~host ~self =
-  let localhost = Helpers.get_localhost ~__context in
-  if not (host = localhost) then
-    Helpers.internal_error "refresh: Host mismatch, expected %s but got %s"
-      (Ref.string_of host) (Ref.string_of localhost) ;
-  refresh_internal ~__context ~self
+  ) ;
+  if pif.API.pIF_physical || pif.API.pIF_currently_attached then (
+    maybe_update_database "PCI" pif.API.pIF_PCI Db.PIF.set_PCI
+      (fun () ->
+        get_device_pci ~__context ~host:pif.API.pIF_host ~device:pif_device_name
+      )
+      Ref.string_of ;
+    maybe_update_database "MTU" pif.API.pIF_MTU Db.PIF.set_MTU
+      (fun () -> Int64.of_int (Net.Interface.get_mtu dbg bridge))
+      Int64.to_string
+  )
 
 let refresh_all ~__context ~host =
   let localhost = Helpers.get_localhost ~__context in
   if not (host = localhost) then
     Helpers.internal_error "refresh_all: Host mismatch, expected %s but got %s"
       (Ref.string_of host) (Ref.string_of localhost) ;
-  (* Only refresh physical or attached PIFs *)
   let pifs =
     Db.PIF.get_refs_where ~__context
-      ~expr:
-        (And
-           ( Eq (Field "host", Literal (Ref.string_of host))
-           , Or
-               ( Eq (Field "physical", Literal "true")
-               , Eq (Field "currently_attached", Literal "true")
-               )
-           )
-        )
+      ~expr:(Eq (Field "host", Literal (Ref.string_of host)))
   in
-  List.iter (fun self -> refresh_internal ~__context ~self) pifs
-
-let bridge_naming_convention (device : string) =
-  if String.starts_with ~prefix:"eth" device then
-    "xenbr" ^ String.sub device 3 (String.length device - 3)
-  else
-    "br" ^ device
+  let interface_tables = make_tables ~__context ~host in
+  List.iter
+    (fun self -> refresh_internal ~__context ~interface_tables ~self)
+    pifs
 
 let read_bridges_from_inventory () =
   try String.split ' ' (Xapi_inventory.lookup Xapi_inventory._current_interfaces)
@@ -337,8 +438,8 @@ let assert_fcoe_not_in_use ~__context ~self =
                  ()
          )
 
-let find_or_create_network (bridge : string) (device : string) ~managed
-    ~__context =
+let find_or_create_network (bridge : string) (device : string)
+    (pos_opt : int option) ~managed ~__context =
   let nets =
     Db.Network.get_refs_where ~__context
       ~expr:(Eq (Field "bridge", Literal bridge))
@@ -352,42 +453,13 @@ let find_or_create_network (bridge : string) (device : string) ~managed
       let () =
         Db.Network.create ~__context ~ref:net_ref ~uuid:net_uuid
           ~current_operations:[] ~allowed_operations:[]
-          ~name_label:(Helpers.choose_network_name_for_pif device)
+          ~name_label:(Helpers.choose_network_name_for_pif device pos_opt)
           ~name_description:"" ~mTU:1500L ~purpose:[] ~bridge ~managed
           ~other_config:[] ~blobs:[] ~tags:[] ~default_locking_mode:`unlocked
           ~assigned_ips:[]
       in
       net_ref
 
-type tables = {
-    device_to_mac_table: (string * string) list
-  ; pif_to_device_table: (API.ref_PIF * string) list
-}
-
-let make_tables ~__context ~host =
-  let dbg = Context.string_of_task __context in
-  let devices =
-    List.filter
-      (fun name -> Net.Interface.is_physical dbg name)
-      (Net.Interface.get_all dbg ())
-  in
-  let pifs =
-    Db.PIF.get_records_where ~__context
-      ~expr:
-        (And
-           ( Eq (Field "host", Literal (Ref.string_of host))
-           , Eq (Field "physical", Literal "true")
-           )
-        )
-  in
-  {
-    device_to_mac_table=
-      List.combine devices
-        (List.map (fun name -> Net.Interface.get_mac dbg name) devices)
-  ; pif_to_device_table=
-      List.map (fun (pref, prec) -> (pref, prec.API.pIF_device)) pifs
-  }
-
 let is_my_management_pif ~__context ~self =
   let net = Db.PIF.get_network ~__context ~self in
   let management_if =
@@ -445,16 +517,19 @@ let db_introduce = pool_introduce
 let db_forget ~__context ~self = Db.PIF.destroy ~__context ~self
 
 (* Internal [introduce] is passed a pre-built table [t] *)
-let introduce_internal ?network ?(physical = true) ~t:_ ~__context ~host ~mAC
-    ~mTU ~device ~vLAN ~vLAN_master_of ?metrics ~managed
-    ?(disallow_unplug = false) () =
-  let bridge = if managed then bridge_naming_convention device else "" in
+let introduce_internal ?network ?(physical = true) ~t ~__context ~host ~mAC ~mTU
+    ~device ~vLAN ~vLAN_master_of ?metrics ~managed ?(disallow_unplug = false)
+    () =
+  let pos_opt = List.assoc_opt device t.device_to_position_table in
+  let bridge =
+    if managed then bridge_naming_convention device pos_opt else ""
+  in
   (* If we are not told which network to use,
      	 * apply the default convention *)
   let net_ref =
     match network with
     | None ->
-        find_or_create_network bridge device ~managed ~__context
+        find_or_create_network bridge device pos_opt ~managed ~__context
     | Some x ->
         x
   in
diff --git a/ocaml/xapi/xapi_pif.mli b/ocaml/xapi/xapi_pif.mli
index 6c83936c1..388d974c5 100644
--- a/ocaml/xapi/xapi_pif.mli
+++ b/ocaml/xapi/xapi_pif.mli
@@ -43,10 +43,6 @@
 
 (** {2 API functions} *)
 
-val refresh :
-  __context:Context.t -> host:[`host] Ref.t -> self:[`PIF] Ref.t -> unit
-(** Refresh the metadata of an existing PIF on the current host. *)
-
 val refresh_all : __context:Context.t -> host:[`host] Ref.t -> unit
 (** Refresh the metadata of all existing PIFs on the current host. *)
 
@@ -160,9 +156,10 @@ val plug : __context:Context.t -> self:[`PIF] Ref.t -> unit
 
 (** {2 Miscellaneous Helper Functions} *)
 
-val bridge_naming_convention : string -> string
-(** Constructs a bridge name from a device (network interface) name by replacing
- *  [eth] by [xenbr], or prepending [br] if the device name does not start with [eth].
+val bridge_naming_convention : string -> int option -> string
+(** Constructs a bridge name from a [device] (network interface) name and an optional
+    position [pos_opt]. If [pos_opt] is Some [pos], the bridge name will be
+    "xenbr" ^ [pos], else "br" ^ [device].
 *)
 
 val read_bridges_from_inventory : unit -> string list
diff --git a/ocaml/xapi/xapi_pool.ml b/ocaml/xapi/xapi_pool.ml
index fdbce5a59..e979fa942 100644
--- a/ocaml/xapi/xapi_pool.ml
+++ b/ocaml/xapi/xapi_pool.ml
@@ -2136,7 +2136,6 @@ let eject_self ~__context ~host =
         configuration_file
     in
     write_first_boot_management_interface_configuration_file () ;
-    Net.reset_state () ;
     Xapi_inventory.update Xapi_inventory._current_interfaces "" ;
     (* Destroy my control domains, since you can't do this from the API [operation not allowed] *)
     ( try
@@ -2215,15 +2214,10 @@ let eject_self ~__context ~host =
               (!Xapi_globs.remote_db_conf_fragment_path ^ ".bak")
           )
           () ;
-        (* Reset the domain 0 network interface naming configuration
-           			 * back to a fresh-install state for the currently-installed
-           			 * hardware.
-        *)
-        ignore
-          (Forkhelpers.execute_command_get_output
-             "/etc/sysconfig/network-scripts/interface-rename.py"
-             ["--reset-to-install"]
-          )
+        (* Reset the domain 0 network interface order back to a fresh-install
+         * state for the currently-installed hardware and reset networkd config.
+         *)
+        Net.reset_state ()
       )
       (fun () -> Xapi_fuse.light_fuse_and_reboot_after_eject ()) ;
     Xapi_hooks.pool_eject_hook ~__context
diff --git a/ocaml/xcp-rrdd/bin/rrdp-netdev/rrdp_netdev.ml b/ocaml/xcp-rrdd/bin/rrdp-netdev/rrdp_netdev.ml
index bd31674a0..97f2d79e1 100644
--- a/ocaml/xcp-rrdd/bin/rrdp-netdev/rrdp_netdev.ml
+++ b/ocaml/xcp-rrdd/bin/rrdp-netdev/rrdp_netdev.ml
@@ -42,17 +42,18 @@ let default_stats =
 
 let monitor_whitelist =
   ref
-    [
-      "eth"
-    ; "vif" (* This includes "tap" owing to the use of standardise_name below *)
-    ]
+    ["vif" (* This includes "tap" owing to the use of standardise_name below *)]
 
 (** Transform names of the form 'tapX.X' to 'vifX.X' so these can be handled
    consistently later *)
 let standardise_name name =
   try Scanf.sscanf name "tap%d.%d" @@ Printf.sprintf "vif%d.%d" with _ -> name
 
-let get_link_stats () =
+let get_link_stats dbg () =
+  let managed_host_net_devs =
+    Network_client.Client.Interface.get_interface_positions dbg ()
+    |> List.map fst
+  in
   let open Netlink in
   let s = Socket.alloc () in
   Socket.connect s Socket.NETLINK_ROUTE ;
@@ -63,9 +64,10 @@ let get_link_stats () =
       List.exists
         (fun s -> Astring.String.is_prefix ~affix:s name)
         !monitor_whitelist
+      || List.mem name managed_host_net_devs
     in
     let is_vlan name =
-      Astring.String.is_prefix ~affix:"eth" name && String.contains name '.'
+      List.mem name managed_host_net_devs && String.contains name '.'
     in
     List.map (fun link -> (standardise_name (Link.get_name link), link)) links
     |> (* Only keep interfaces with prefixes on the whitelist, and exclude VLAN
@@ -160,7 +162,7 @@ let generate_netdev_dss () =
     Network_client.Client.Bridge.get_all_bonds dbg from_cache
   in
 
-  let stats = get_link_stats () |> add_bonds bonds |> transform_taps in
+  let stats = get_link_stats dbg () |> add_bonds bonds |> transform_taps in
   let dss, sum_rx, sum_tx =
     List.fold_left
       (fun (dss, sum_rx, sum_tx) (dev, stat) ->
diff --git a/python3/bin/xe-reset-networking b/python3/bin/xe-reset-networking
index 81b3c5728..2802eee3e 100755
--- a/python3/bin/xe-reset-networking
+++ b/python3/bin/xe-reset-networking
@@ -24,7 +24,8 @@ pool_conf = '@ETCXENDIR@/pool.conf'
 inventory_file = '@INVENTORY@'
 management_conf = '/etc/firstboot.d/data/management.conf'
 network_reset = '/var/tmp/network-reset'
-
+RENAME_SCRIPT = '/etc/sysconfig/network-scripts/interface-rename.py'
+rename_script_exists = os.path.exists(RENAME_SCRIPT)
 
 @contextmanager
 def fsync_write(filename):
@@ -66,6 +67,16 @@ def valid_vlan(vlan):
         return False
     return True
 
+def get_bridge_name(device, vlan):
+    # Construct bridge name for management interface based on convention
+    # NOTE: Only correct when interface-rename script exists
+    if vlan != None:
+        return 'xentemp'
+    m = re.match(r'^eth(\d+)$', device)
+    if m:
+        return 'xenbr' + m.group(1)
+    return 'br' + device
+
 if __name__ == "__main__":
     parser = OptionParser()
     parser.add_option("-m", "--master", help="Master's address", dest="address", default=None)
@@ -208,15 +219,9 @@ Type 'no' to cancel.
         with fsync_write(pool_conf) as f:
             f.write('slave:' + address)
 
-    # Construct bridge name for management interface based on convention
-    if device[:3] == 'eth':
-        bridge = 'xenbr' + device[3:]
-    else:
-        bridge = 'br' + device
-
     # Ensure xapi is not running
     print("Stopping xapi...")
-    os.system('service xapi stop >/dev/null 2>/dev/null')
+    os.system('systemctl stop xapi >/dev/null 2>/dev/null')
 
     # Reconfigure new management interface
     print("Reconfiguring " + device + "...")
@@ -229,10 +234,10 @@ Type 'no' to cancel.
     # Update interfaces in inventory file
     print('Updating inventory file...')
     inventory = read_inventory()
-    if vlan != None:
-        inventory['MANAGEMENT_INTERFACE'] = 'xentemp'
-    else:
-        inventory['MANAGEMENT_INTERFACE'] = bridge
+    # If rename script does not exist, needn't to set MANAGEMENT_INTERFACE in inventory file
+    # Networkd will handle it while replacing the rename script to sort interfaces
+    bridge = '' if not rename_script_exists else get_bridge_name(device, vlan)
+    inventory['MANAGEMENT_INTERFACE'] = bridge
     inventory['CURRENT_INTERFACES'] = ''
     write_inventory(inventory)
 
@@ -280,11 +285,11 @@ Type 'no' to cancel.
                 f.write('GATEWAY_V6=' + options.gateway_v6 + '\n')
         if is_static and options.dns != '':
             f.write('DNS=' + options.dns + '\n')
-
-    # Reset the domain 0 network interface naming configuration
-    # back to a fresh-install state for the currently-installed
-    # hardware.
-    os.system("/etc/sysconfig/network-scripts/interface-rename.py --reset-to-install")
+    if rename_script_exists:
+        # Reset the domain 0 network interface naming configuration
+        # back to a fresh-install state for the currently-installed
+        # hardware.
+        os.system(f"{RENAME_SCRIPT} --reset-to-install")
 
     # Reboot
     os.system("mount -o remount,rw / && reboot -f")
diff --git a/scripts/network-init b/scripts/network-init
index b6fa79699..7065ec896 100755
--- a/scripts/network-init
+++ b/scripts/network-init
@@ -100,9 +100,9 @@ prepare_networking() {
 
 rename_network_label() {
     # In common criteria certification deployment, user must ensure:
-    # - The 1st NIC (eth0) is for Management Network
-    # - The 2nd NIC (eth1) is for Storage Network
-    # - others (ethX, X>=2) is for Guest Network
+    # - The 1st NIC is for Management Network
+    # - The 2nd NIC is for Storage Network
+    # - others (X>=2) is for Guest Network
     # This function is to rename these network labels to appropriate.
 
     if [ "${CC_PREPARATIONS}" != "true" ]; then
@@ -110,9 +110,18 @@ rename_network_label() {
         return
     fi
 
-    for device in $(ls /sys/class/net | grep -E '^eth[0-9]+$')
+    for device_path in /sys/class/net/*
     do
-        device_id=$(echo ${device} | sed 's/^eth//')
+        device=$(basename "${device_path}")
+        network_uuid=$(${XE} pif-list device="${device}" params=network-uuid --minimal)
+        if [ -z "${network_uuid}" ]; then
+            continue
+        fi
+        bridge=$(${XE} network-list uuid="${network_uuid}" params=bridge --minimal)
+        if [ -z "${bridge}" ]; then
+            continue
+        fi
+        device_id=$(echo ${bridge} | sed 's/^xenbr//')
         if [ ${device_id} -eq 0 ]; then
             name_label="Management Network"
         elif [ ${device_id} -eq 1 ]; then
@@ -127,8 +136,7 @@ rename_network_label() {
             continue
         fi
 
-        network_uuid=$(${XE} pif-list device=${device} params=network-uuid --minimal)
-        ${XE} network-param-set uuid=${network_uuid} name-label="${name_label}"
+        ${XE} network-param-set uuid="${network_uuid}" name-label="${name_label}"
         echo "Renamed network label of ${network_uuid} to ${name_label}, device: ${device}"
     done
 }
diff --git a/scripts/xcp-networkd.service b/scripts/xcp-networkd.service
index c80b5b630..2422c740a 100644
--- a/scripts/xcp-networkd.service
+++ b/scripts/xcp-networkd.service
@@ -1,8 +1,16 @@
 [Unit]
 Description=XCP networking daemon
 Documentation=man:xcp-networkd(1)
-After=forkexecd.service message-switch.service syslog.target
-Wants=forkexecd.service message-switch.service syslog.target
+After=systemd-udev-settle.service
+After=systemd-udev-trigger.service
+After=forkexecd.service
+After=message-switch.service
+After=syslog.target
+Wants=systemd-udev-settle.service
+Wants=systemd-udev-trigger.service
+Wants=forkexecd.service
+Wants=message-switch.service
+Wants=syslog.target
 PartOf=toolstack.target
 
 [Service]
