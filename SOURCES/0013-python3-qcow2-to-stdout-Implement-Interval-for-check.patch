From 81b1dc3f69ae6fef1006ddd917f7788391315d29 Mon Sep 17 00:00:00 2001
From: Andrii Sultanov <andriy.sultanov@vates.tech>
Date: Wed, 4 Feb 2026 13:20:56 +0000
Subject: [PATCH] python3/qcow2-to-stdout: Implement Interval for checking
 sparse cluster allocation

Instead of using a set with every individual allocated cluster index as a
member, use a sorted list of intervals to verify if cluster is allocated - this
uses much less memory and directly follows from the JSON format
qcow-stream-tool and vhd-tool output now.

Signed-off-by: Andrii Sultanov <andriy.sultanov@vates.tech>
---
 python3/libexec/qcow2-to-stdout.py | 58 ++++++++++++++++++++++++++++++
 1 file changed, 58 insertions(+)

diff --git a/python3/libexec/qcow2-to-stdout.py b/python3/libexec/qcow2-to-stdout.py
index 4ce1cc72b..1f876ec4e 100755
--- a/python3/libexec/qcow2-to-stdout.py
+++ b/python3/libexec/qcow2-to-stdout.py
@@ -91,6 +91,64 @@ def write_features(cluster, offset, data_file_name):
         offset += 48
 
 
+class Interval:
+    """
+    Represents the allocated virtual cluster intervals in a sparse file
+    """
+    def __init__(self, lst):
+        self.intervals = lst
+        self.intervals.sort(key=lambda x: x[0])
+
+
+    def __contains__(self, cluster):
+        """
+        Checks if cluster is in one of the intervals, removes it from the
+        interval if true
+        """
+        # Check if cluster is within [min, max]
+        if self.intervals[-1][1] < cluster or self.intervals[0][0] > cluster:
+            return False
+
+        # Binary search for the interval that could contain the cluster
+        l = 0
+        h = len(self.intervals) - 1
+        while l <= h:
+            mid = (l + h) // 2
+            current = self.intervals[mid]
+
+            if cluster >= current[0] and cluster <= current[1]:
+                if cluster == current[0] and cluster == current[1]:
+                    # Remove the cluster from the interval
+                    del self.intervals[mid]
+                    return True
+
+                if cluster == current[0]:
+                    # Shrink interval from the left
+                    left = current[0] + 1
+                    right = current[1]
+                elif cluster == current[1]:
+                    # Shrink interval from the right
+                    left = current[0]
+                    right = current[1] - 1
+                else:
+                    # Split the original interval into two
+                    left = current[0]
+                    right = cluster
+                    self.intervals.insert(mid+1, [cluster+1, current[1]])
+
+                self.intervals[mid] = [left, right]
+                return True
+            elif cluster < current[0]:
+                h = mid - 1
+            elif cluster > current[1]:
+                l = mid + 1
+
+        return False
+
+    def __iter__(self):
+        return self.intervals.__iter__()
+
+
 def write_qcow2_content(input_file, cluster_size, refcount_bits,
                         data_file_name, data_file_raw, diff_file_name,
                         virtual_size, nonzero_clusters,
